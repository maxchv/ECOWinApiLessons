// Lesson02.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <Windows.h>

// Утилита Spy++
// «Новые» типы данных
void ex01()
{
	// Новые типы
	/*
	BOOL		Булевский тип данных.Может принимать одно из двух значений TRUE или FALSE.Занимает 4 байта.
	BYTE		1 - байтное целое без знака.
	INT			4 - х байтное целое со знаком.
	LONG		4 - х байтное целое со знаком.
	UINT		4 - х байтное целое без знака.
	WORD		2 - х байтное целое без знака.
	DWORD		4 - х байтное целое или адрес.
	*/
	WORD w;

	// Параметры
	/*
	LPARAM		Переменные этого типа передаются в качестве дополнительного параметра в функцию -
<<<<<<< HEAD
	обработчик какого - либо сообщения.В них обычно содержатся информация
	специфическая для данного события.Занимает 4 байта.
	WPARAM		Переменные этого типа передаются в качестве дополнительного параметра в функцию -
	обработчик какого - либо сообщения.В них обычно содержатся информация
	специфическая для данного события.
	Занимает 4 байта.
=======
				обработчик какого - либо сообщения.В них обычно содержатся информация
				специфическая для данного события.Занимает 4 байта.
	WPARAM		Переменные этого типа передаются в качестве дополнительного параметра в функцию -
				обработчик какого - либо сообщения.В них обычно содержатся информация
				специфическая для данного события.
				Занимает 4 байта.
>>>>>>> refs/remotes/origin/solution
	*/

	// Цвет
	// COLORREF	Тип данных, используемый для работы с цветом.Занимает 4 байта.

	// Дескрипторы
	/*
	HANDLE		4 - х байтное целое, используемое в качестве дескриптора.
	HBITMAP		Дескриптор растрового изображения.
	HBRUSH		Дескриптор кисти.
	HCURSOR		Дескриптор курсора.
	HDC			Дескриптор устройства.
	HFONT		Дескриптор шрифта.
	HICON		Дескриптор иконки.
	HINSTANCE	Дескриптор экземпляра приложения.
	HMENU		Дескриптор меню.
	HWND		Дескриптор окна.
	*/
<<<<<<< HEAD

	// Указатели
	/*
	LPCSTR		4 - х байтный указатель на константную строку символов.
	Указатели с приставкой LP обычно называют длинными указателями.
=======
	
	// Указатели
	/*
	LPCSTR		4 - х байтный указатель на константную строку символов.
		        Указатели с приставкой LP обычно называют длинными указателями.
>>>>>>> refs/remotes/origin/solution
	LPCWSTR		4 - х байтный указатель на константную Unicode - строку.
	LPSTR		4 - х байтный указатель строку символов.
	LPWSTR		4 - х байтный указатель на Unicode - строку.
	LRESULT		Значение типа LONG, возвращаемое оконной процедурой
<<<<<<< HEAD
	*/
=======
	*/	
>>>>>>> refs/remotes/origin/solution
}

// Венгерская нотация
void ex02()
{
	/*
	b	Логический тип(bool или BOOL)
	i	Целое число(индекс)
	n	Целое число(количество чего - либо)
	u	Целое число без знака
	d	Число с двойной точностью
	sz	Строковая переменная, ограниченная нулем
	p	Указатель
	lp	Длинный указатель
	a	Массив
	lpfn	Длинный указатель на функцию
	h	Дескриптор
	cb	Счетчик байтов
	C	Класс
	*/
	BOOL bIsShow;

	LPSTR lpszWinName = "MyWindow";
<<<<<<< HEAD

	//....

=======

	//....

>>>>>>> refs/remotes/origin/solution
	bIsShow = true;
}

// Этапы создания проекта «Win32 Project»
// Минимальное WinAPI-приложение
void ex03()
{
	// Прототип главной функции WinMain
	/*
	INT WINAPI WinMain(
<<<<<<< HEAD
	HINSTANCE hInst,	// дескриптор экземпляра приложения
	HINSTANCE hPrevInst,//равен 0 и необходим для совместимости
	LPTSTR lpszCmdLine, // указатель на строку, в которую копируются
	//аргументы приложения, если оно запущено в режиме командной строки
	int nCmdShow		// способ визуализации окна при запуске программы
=======
		HINSTANCE hInst,	// дескриптор экземпляра приложения
		HINSTANCE hPrevInst,//равен 0 и необходим для совместимости
		LPTSTR lpszCmdLine, // указатель на строку, в которую копируются 
							//аргументы приложения, если оно запущено в режиме командной строки
		int nCmdShow		// способ визуализации окна при запуске программы
>>>>>>> refs/remotes/origin/solution
	);
	*/
	/*
	Спецификатор WINAPI определяет соглашение о вызове функции.
<<<<<<< HEAD
	1. __cdecl – по данному протоколу вызывающая функция сама очищает
	стек после вызываемой функции.
	2. __stdcall (WINAPI, CALLBACK) – согласно этому протоколу вызываемая
	функция сама за собой очищает стек.
=======
	1. __cdecl – по данному протоколу вызывающая функция сама очищает 
	   стек после вызываемой функции.
	2. __stdcall (WINAPI, CALLBACK) – согласно этому протоколу вызываемая 
	   функция сама за собой очищает стек.
>>>>>>> refs/remotes/origin/solution
	*/

	// Класс окна WNDCLASSEX
	/*
	typedef struct tagWNDCLASSEX {
	UINT cbSize;			// размер данной структуры в байтах
	UINT style;				// стиль класса окна
	WNDPROC lpfnWndProc;	// указатель на функцию окна (оконную процедуру)
	int cbClsExtra;			// число дополнительных байтов, которые должны
	//быть распределены в конце структуры класса
	int cbWndExtra;			// число дополнительных байтов, которые должны
	//быть распределены вслед за экземпляром окна
	HINSTANCE hInstance;	// дескриптор экземпляра приложения, в котором
	//находится оконная процедура для этого класса
	HICON hIcon;			// дескриптор иконки
	HCURSOR hCursor;		// дескриптор курсора
	HBRUSH hbrBackground;	//дескриптор кисти, используемой для закраски фона окна
	LPCTSTR lpszMenuName;	// указатель на строку, содержащую имя меню,
	//применяемого по умолчанию для этого класса
	LPCTSTR lpszClassName;	// указатель на строку, содержащую имя класса окна
	HICON hIconSm;			// дескриптор малой иконки
	} WNDCLASSEX;

	*/

	// LoadIcon, LoadCursor, GetStockObject 

	// Регистрация класса окна
	/* ATOM RegisterClassEx(
<<<<<<< HEAD
	CONST WNDCLASS * lpWClass // адрес структуры WNDCLASSEX
	);*/

	// Создание окна.
	/*
	HWND CreateWindow(
	LPCTSTR lpClassName, // имя класса окна
	LPCTSTR lpWinName, // заголовок окна
	DWORD dwStyle, // стиль окна
	int x, int у, // координаты верхнего левого угла
	int Width, int Height, // размеры окна
	HWND hParent, // дескриптор родительского окна
	HMENU hMenu, // дескриптор главного меню
	HINSTANCE hThisInst, // дескриптор приложения
	LPVOID lpszAdditional // указатель на дополнительную информацию
=======
		CONST WNDCLASS * lpWClass // адрес структуры WNDCLASSEX
	 );*/

	// Создание окна.
	/*
	HWND CreateWindow(	
		LPCTSTR lpClassName, // имя класса окна
		LPCTSTR lpWinName, // заголовок окна
		DWORD dwStyle, // стиль окна
		int x, int у, // координаты верхнего левого угла
		int Width, int Height, // размеры окна
		HWND hParent, // дескриптор родительского окна
		HMENU hMenu, // дескриптор главного меню
		HINSTANCE hThisInst, // дескриптор приложения
		LPVOID lpszAdditional // указатель на дополнительную информацию
>>>>>>> refs/remotes/origin/solution
	);*/

	// Стили окна
	/*
	WS_OVERLAPPED	Стандартное окно с рамкой
	WS_MAXIMIZEBOX	Наличие кнопки развертки
	WS_MINIMIZEBOX	Наличие кнопки минимизации
	WS_SYSMENU	Наличие системного меню
	WS_HSCROLL	Наличие горизонтальной панели прокрутки
	WS_VSCROLL	Наличие вертикальной панели прокрутки
	*/

	// Отображение окна
	/* BOOL ShowWindow(
<<<<<<< HEAD
	HWND hWnd, //дескриптор окна
	int nCmdShow //способ отображения окна
	);
	*/
	/*
	Способ отображения окна:
	SW_HIDE	Скрыть окно
	SW_MAXIMIZE	Развернуть окно
	SW_MINIMIZE	Свернуть окно
	SW_SHOW	Активизировать окно и показать в его текущих размерах и позиции
	SW_RESTORE	Отобразить окно в нормальном представлении
	*/
	/*
	UpdateWindow посылает оконной процедуре сообщение WM_PAINT,
	заставляющее окно перерисовать свою клиентскую область.

	BOOL UpdateWindow( HWND hWnd );
=======
			HWND hWnd, //дескриптор окна
			int nCmdShow //способ отображения окна
		);
	*/
	/*
		Способ отображения окна:
		SW_HIDE	Скрыть окно
		SW_MAXIMIZE	Развернуть окно
		SW_MINIMIZE	Свернуть окно
		SW_SHOW	Активизировать окно и показать в его текущих размерах и позиции
		SW_RESTORE	Отобразить окно в нормальном представлении
>>>>>>> refs/remotes/origin/solution
	*/
	/*
		UpdateWindow посылает оконной процедуре сообщение WM_PAINT, 
		заставляющее окно перерисовать свою клиентскую область.

		BOOL UpdateWindow( HWND hWnd );
	*/

	// Цикл обработки сообщений
	/*
<<<<<<< HEAD
	BOOL GetMessage(
	LPMSG lpMsg,//адрес структуры MSG, в которую помещается выбранное сообщение
	HWND hwnd,	// дескриптор окна, принимающего сообщение
	// Обычно значение этого параметра равно NULL, что позволяет выбрать
	// сообщения для любого окна приложения.
	UINT min,	// минимальный номер принимаемого  сообщения
	UINT max	// максимальный номер принимаемого сообщения
	// Если оба последних параметра равны нулю, то функция выбирает из очереди
	// любое очередное сообщение.
	);

	// трансляция сообщения
	BOOL WINAPI TranslateMessage(
	_In_ const MSG *lpMsg
	);

	// диспетчеризация сообщений
	LRESULT WINAPI DispatchMessage(
	_In_ const MSG *lpmsg
	);
=======
		BOOL GetMessage(
		LPMSG lpMsg,//адрес структуры MSG, в которую помещается выбранное сообщение
		HWND hwnd,	// дескриптор окна, принимающего сообщение
					// Обычно значение этого параметра равно NULL, что позволяет выбрать 
					// сообщения для любого окна приложения. 
		UINT min,	// минимальный номер принимаемого  сообщения
		UINT max	// максимальный номер принимаемого сообщения
					// Если оба последних параметра равны нулю, то функция выбирает из очереди 
					// любое очередное сообщение. 
		);

		// трансляция сообщения
		BOOL WINAPI TranslateMessage(
			_In_ const MSG *lpMsg
		);

		// диспетчеризация сообщений
		LRESULT WINAPI DispatchMessage(
			_In_ const MSG *lpmsg
		);
>>>>>>> refs/remotes/origin/solution
	*/

	// Оконная процедура
	// LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
	// PostQuitMessage(0) - посылка сообщения WM_QUIT
	// DefWindowProc - системная функция обработки сообщений

}

// Окна сообщений
void ex04()
{
	// MessageBox
	/*
	int MessageBox(
	HWND hWnd,			// дескриптор родительского окна
	// Если этот параметр равен 0, то окно сообщения не имеет окна владельца.
	LPCTSTR lpText,		// указатель на строку, содержащую текст, который должен быть
	// отображен в окне
	LPCTSTR lpCaption,	// указатель на строку, которая отображается в заголовке
	// диалогового окна
	// Если этот параметр равен NULL, то применяется  заданный по умолчанию
	// заголовок Error.
	UINT uType			// этот параметр является комбинацией значений, которые определяют свойства
	// окна сообщения, включающие типы кнопок, которые должны присутствовать, и
	// дополнительную иконку рядом с текстом сообщения
	);
	*/

	// Типы кнопок
	/*
	MB_OK				Окно содержит только кнопку OK (Подтверждение)
	MB_OKCANCEL			Окно содержит две кнопки: OK (Подтверждение) и Cancel (Отмена)
	MB_RETRYCANCEL		Окно содержит две кнопки: Retry и Cancel (Повтор и Отмена)
	MB_ABORTRETRYIGNORE	Окно содержит три кнопки: Abort, Retry и Ignore (Стоп, Повтор и Пропустить)
	MB_YESNO			Окно содержит две кнопки: Yes и No (Да и Нет)
	MB_YESNOCANCEL		Окно содержит три кнопки: Yes, No и Cancel (Да, Нет и Отмена)
	*/

	// Иконки
	/*
	MB_ICONEXCLAMATION				// Отображается иконка «восклицательный знак»
	MB_ICONINFORMATION				// Отображается иконка «информация»
	MB_ICONQUESTION					// Отображается иконка «вопросительный знак»
	MB_ICONSTOP (или MB_ICONHAND)	// Отображается иконка – «стоп»
	*/

	// Возвращаемое значение
	/*
	IDOK		// Была нажата кнопка OK
	IDCANCEL	// Была нажата кнопка Cancel (или клавиша <Esc>)
	IDABORT		// Была нажата кнопка Abort
	IDIGNORE	// Была нажата кнопка Ignore
	IDYES		// Была нажата кнопка Yes
	IDNO		// Была нажата кнопка No
	IDRETRY		// Была нажата кнопка Retry
	0			// Произошла ошибка при создании окна сообщений
	*/
}

// Домашнее задание
/*
<<<<<<< HEAD
1.	Написать приложение, позволяющее вывести на экран краткое резюме с помощью
последовательности окон  сообщений (количество окон сообщений – не менее трёх).

На заголовке последнего окна сообщения должно отобразиться среднее число символов на странице
=======
1.	Написать приложение, позволяющее вывести на экран краткое резюме с помощью 
последовательности окон  сообщений (количество окон сообщений – не менее трёх). 

На заголовке последнего окна сообщения должно отобразиться среднее число символов на странице 
>>>>>>> refs/remotes/origin/solution
(общее число символов в резюме поделить на количество окон сообщений).

2.	Написать приложение, которое «угадывает» задуманное пользователем число от 1 до 100.
Для запроса к пользователю использовать окна сообщений. После того, как число отгадано,
необходимо вывести количество попыток, потребовавшихся для этого, и предоставить пользователю
возможность сыграть еще раз, не завершая программу. Окна сообщений следует оформить кнопками
и иконками в соответствии с конкретной ситуацией.

*/

int main()
{
	return 0;
}

