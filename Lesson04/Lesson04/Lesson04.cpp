//

#include "stdafx.h"

// Повторение пройденного материала

/*
1)	Какие бывают сообщения мыши? Какая дополнительная информация 
    приходит с этими сообщениями?
2)	Какие существуют клавиатурные сообщения? Какая дополнительная информация 
    приходит с этими сообщениями?
3)	В каком случае следует обрабатывать сообщение WM_CHAR, 
    а в каком случае – WM_KEYDOWN и WM_KEYUP?
4)	Какой функцией можно определить состояние указанной виртуальной клавиши?
5)	Какой функцией можно вывести текст в заголовок окна?
6)	Чем отличается функция GetWindowRect от функции GetClientRect?
7)	Как преобразовать экранные координаты указанной точки в клиентские 
    координаты относительно левого верхнего угла рабочей области заданного окна ?
8)	Как выполнить обратное преобразование?
9)	Каким образом можно переместить окно, а также изменить его размеры ?
10)	Какая функция позволяет получить дескриптор окна верхнего уровня? 
    Какую информацию необходимо передать в эту функцию?
11)	Какая функция позволяет получить дескриптор дочернего окна? 
    Какую информацию необходимо передать в эту функцию?
12)	С помощью какого средства можно определить заголовок и класс окна?
*/

// Работа с таймером
void ex01()
{
	//Для установки таймера необходимо использовать функцию API SetTimer:
	/*
	UINT SetTimer(
		HWND hwnd,		// дескриптор окна, которое собирается использовать таймер
		UINT nID,		// идентификатор устанавливаемого таймера 
		UINT wLength,	// временной интервал для таймера в миллисекундах
		TIMEPROC lpTFunc// указатель на функцию - обработчик прерываний таймера
		);

	Функция-обработчик таймера должна иметь следующий прототип:

	VOID CALLBACK TimerProc(
		HWND hwnd,			// дескриптор окна, которое собирается использовать таймер
		UINT uMsg,			// идентификатор сообщения WM_TIMER
		UINT_PTR idEvent,	// идентификатор устанавливаемого таймера
		DWORD dwTime		// временной интервал для таймера в миллисекундах
	)
	*/
	/*
	Если указатель lpTFunc равен NULL, то, для обработки сообщений таймера будет 
	вызываться оконная процедура главного окна приложения. 
	В этом случае каждый раз по истечении заданного временного интервала в очередь 
	сообщений программы будет помещаться сообщение WM_TIMER
	*/

	/*
	Останов таймера:

	BOOL KillTimer(
			HWND hwnd, // дескриптор окна, использующего таймер
			UINT nID   // идентификатор таймера
		);
	*/
}

// Перечисление окон.
void ex02()
{
	//Для перечисления всех окон верхнего уровня:
	/*
	
	BOOL EnumWindows(
		WNDENUMPROC lpEnumFunc, // указатель на функцию обратного вызова
		LPARAM lParam // аргумент, передаваемый в функцию обратного вызова
		);
		
	Прототип функции обратного вызова имеет следующий вид:

	BOOL CALLBACK EnumWindowsProc(
		HWND hwnd, // дескриптор очередного перечисленного окна верхнего уровня
		LPARAM lParam  // аргумент, переданный в CALLBACK-функцию
		);

	Для продолжения перечисления окон, функция должна возвращать TRUE, в 
	противном случае перечисление прекратится.
	*/

	//Для перечисления дочерних окон указанного окна верхнего уровня:
	/*
	BOOL EnumChildWindows(
		HWND hWndParent, // дескриптор родительского окна
		WNDENUMPROC lpEnumFunc, // указатель на функцию обратного вызова
		LPARAM lParam // аргумент, передаваемый в функцию обратного вызова
		);

	Прототип функции обратного вызова имеет следующий вид:

	BOOL CALLBACK EnumChildProc(
		HWND hwnd, // дескриптор очередного перечисленного окна
		LPARAM lParam  // аргумент, переданный в CALLBACK-функцию
		);
	
	Для продолжения перечисления окон, CALLBACK–функция должна возвращать TRUE, 
	в противном случае перечисление прекратится.
	*/

	/*
	Получить информацию о окне:

	Функция GetWindowText копирует текст строки заголовка определяемого окна 
	(если оно имеет ее) в буфер. Если определяемое окно - элемент управления, 
	текст элемента управления копируется.

	int GetWindowText
	(
		HWND hWnd,			// дескриптор окна или элемента управления с текстом
		LPTSTR lpString,	// адрес буфера для текста
		int nMaxCount 		// максимальное число символов для копирования
	);

	Функция GetClassName получает оконного класса указанного окна.

	int GetClassName(
		HWND hWnd,			// дескриптор окна
		LPTSTR lpClassName,	// адрес буфера для имени класса
		int nMaxCount 		// размер буфера в символах
	);
	*/

}

// Ресурсы приложения.
void ex03()
{
	/*
		Все нестандартные ресурсы должны быть определены в файле описания ресурсов 
		(resource script), который является ASCII-файлом с расширением .гс.
	*/

	// Пиктограмма.
	/*
		Пиктограммы (иконки) — это небольшие растровые изображения, применяемые Windows 
		для визуального представления приложений, файлов и папок. Чаще всего для 
		приложения создают иконки следующих типовых размеров:        
			16 x 16 пикселей для малых иконок и 
			32 х 32 пикселя для стандартных иконок.
	*/

	/*
	Для загрузки иконки находящейся в ресурсах приложения используют функию LoadIcon:

	HICON LoadIcon(
		HINSTANCE hInst, //дескриптор экземпляра приложения, содержащего иконку
		LPCTSTR lpszName //строка, содержащая имя иконки
		);

	HMODULE GetModuleHandle(
		LPCTSTR lpModuleName // имя DLL модуля 
		);

	Если аргумент функции GetModuleHandle нулевой, то возвращается дескриптор экземпляра
	приложения.

	Поскольку имя иконки представляет собой целочисленный идентификатор 
	(например, IDI_ICON1), то его можно преобразовать в строку с помощью макроса  
	MAKEINTRESOURCE (make an integer into resource string):

		#define MAKEINTRESOURCE(i)  (LPTSTR) ((DWORD) ((WORD) (i)))


	*/

	// Курсор.
	/*
		Курсор — это изображение размером 32 х 32 пикселя, которое отмечает  положение  
		указателя мыши. Курсор во многом похож на иконку. Главное отличие заключается 
		в наличии активной точки (hotspot).
	*/
	/*
	Для использования в программе курсора, находящегося в ресурсах приложения, курсор 
	следует загрузить с помощью функции LoadCursor:

		HCURSOR LoadCursor (
			HINSTANCE hInst, // дескриптор экземпляра приложения, содержащего курсор
			LPCTSTR lpszName // строка, содержащая имя курсора
		);

	Для динамического изменения формы курсора в зависимости от его
	местонахождения применяется функция SetCursor:

		HCURSOR SetCursor(
			HCURSOR hCursor // дескриптор курсора
		);
	*/

	/*
	Для изменения стиля окна применяется функция SetClassLong. Пример:

		HICON hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
		SetClassLong(hWnd, GCL_HICON, LONG(hIcon));
	
		HCURSOR hCursor1 = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR1));
		SetClassLong(hWnd, GCL_HCURSOR, LONG(hCursor1));


	*/
}

// Обработка ошибок.
void ex04()
{
	/*При возникновении ошибки задается свой код — 32-битное число, 
	которое можно получить, вызвав функцию GetLastError.
	
	Если GetLastError возвращает нулевое значение, это означает, что предшествующий
	вызов функции Windows завершился успешно.
	*/

	/*
	Для получения описания ошибки на основе кода ошибки существует  FormatMessage:

	DWORD FormatMessage(
		DWORD dwFlags, // набор битовых флагов, которые определяют различные   	// аспекты процесса форматирования, а также способ интерпретации      	// 2-го параметра lpSource
		LPCVOID lpSource, // указатель на строку, содержащую сообщение об ошибке
		DWORD dwMessageId, // код ошибки
		DWORD dwLanguageId, // идентификатор языка, на котором выводится 		// описание ошибки
		LPTSTR lpBuffer, // выходной буфер, который выделяется системой, если
		// в 1-м параметре указан флаг FORMAT_MESSAGE_ALLOCATE_BUFFER
		DWORD nSize, // число символов, записываемых в выходной буфер,
		// либо минимальный размер выделяемого буфера, если
		// в 1-м параметре указан флаг FORMAT_MESSAGE_ALLOCATE_BUFFER
		va_list* Arguments // список аргументов форматирования
	);

	Пример:
	DWORD dwError = GetLastError(); // получим код последней ошибки
	LPVOID lpMsgBuf = NULL;
	TCHAR szBuf[300];
	//Функция FormatMessage форматирует строку сообщения
	BOOL fOK = FormatMessage(
			FORMAT_MESSAGE_FROM_SYSTEM // флаг сообщает функции, что нужна строка, 	соответствующая коду ошибки, определённому в системе 
			| FORMAT_MESSAGE_ALLOCATE_BUFFER // необходимо выделить соответствующий 	блок памяти для хранения текста с описанием ошибки ,
			NULL // текст с описанием ошибки будет находиться в буфере, выделенном 	системой. Адрес задается в 5-м параметре ,
			dwError // код ошибки ,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT) // идентификатор языка, на 	котором выводится описание ошибки ,
			(LPTSTR)&lpMsgBuf // указатель на буфер, в который запишется текст с 	описанием ошибки ,
			0, // память выделяет система
			NULL // список аргументов форматирования
			);
			if (lpMsgBuf != NULL)
			{
				wsprintf(szBuf, TEXT("Ошибка %d: %s"), dwError, lpMsgBuf);
				MessageBox(hDialog, szBuf, TEXT("Сообщение об ошибке"), MB_OK | MB_ICONSTOP);
				LocalFree(lpMsgBuf); // освободим память, выделенную системой
			}
	*/
}

// Практическая часть.
/*
Написать приложение, обладающее следующей функциональностью:
•	после нажатия клавиши <Enter> через каждую секунду (или иной проме-жуток времени) «прячется» одна из кнопок «Калькулятора»,  выбранная случайным образом;
•	после нажатия клавиши <Esc> данный процесс останавливается.
*/

// Домашнее задание.
/*
1.	Написать  приложение,  обладающее  следующей функциональностью:
	при нажатии клавиши <Enter> главное окно позиционируется в левый верхний угол 
	экрана с размерами (300х300) и начинает перемещаться по периметру экрана 
	с определённой скоростью;
	при нажатии клавиши <Esc> перемещение окна прекращается.

2.	Написать  приложение,  обладающее  следующей    функциональностью:
	при последовательном нажатии клавиши <Enter> дочерние окна главного окна 
	приложения «Калькулятор» минимизируются;
	при последовательном нажатии клавиши <Esc> дочерние окна восстанавливаются в 
	обратном порядке, т.е. дочернее окно, которое минимизировалось последним, 
	первым будет восстановлено.
*/


int main(int argc, TCHAR* argv[])
{
	return 0;
}

