// SynchronizeThreads3.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"

//
/*
1.	Что такое мьютекс?
2.	В чем заключается принцип синхронизации потоков с помощью 
	мьютексов?
3.	В чем состоит основное отличие мьютекса от критической секции?
4.	Какая функция WinAPI предусмотрена для создания мьютекса?
5.	Какая функция WinAPI позволяет получить дескриптор существующего
	мьютекса?
6.	Какая функция WinAPI используется для получения доступа к 
	разделяемому ресурсу?
7.	Посредством какой функции WinAPI поток освобождает захваченный 
	мьютекс?
8.	Какая функция WinAPI позволяет ждать освобождения сразу 
	нескольких объектов синхронизации?
9.	Что такое семафор? Чем он отличается от мьютекса?
10.	В чем состоит принцип синхронизации работы потоков с 
	использованием семафоров?
11.	Какая функция WinAPI предусмотрена для создания семафора?
12.	Какая функция WinAPI позволяет получить дескриптор 
	существующего семафора?
13.	Какая функция WinAPI позволяет увеличить счетчик текущего 
	числа ресурсов?
*/

// 1.	События.
/*
Событие (event) — это объект ядра, предназначенный для синхронизации 
работы потоков. 

Чаще всего событие используется для уведомления об окончании 
какой-либо операции.

События бывают двух типов:
	•	со сбросом вручную (manual-reset events);
	•	с автоматическим сбросом (auto-reset events).
События с ручным сбросом позволяют возобновить выполнение сразу 
нескольких ждущих потоков, в то время как события с автоматическим
сбросом  возобновляют выполнение только одного потока.

Объект ядра «событие» создается функцией API CreateEvent.

HANDLE CreateEvent(
	LPSECURITY_ATTRIBUTES eventAttributes,	// атрибуты доступа
	BOOL bManualReset,						// тип сброса
	BOOL bInitialState,						// начальное состояние
	LPCTSTR pszName							// имя объекта
);

Параметр bManualReset определяет тип объектасобытия. 

Значение TRUE  создает событие со сбросом вручную, 
а значение FALSE — событие с автоматическим сбросом. 

Параметр blnitialState определяет начальное состояние события — 
свободное (TRUE) или занятое (FALSE). 

Параметр pszName содержит указатель на строку, в которой содержится
имя объекта. 

Если pszName имеет значение NULL, то создается неименованный объект.

Синхронизация работы потоков с использованием событий состоит 
в следующем. 

Предположим, что некоторый поток, создавший объект ядра «событие»,
переводит его в занятое состояние и приступает к своим операциям. 

Закончив работу, поток сбрасывает событие в свободное состояние. 
В этот момент другой поток, который ждал перехода события в 
свободное состояние, пробуждается и становится планируемым.

События могут использоваться для синхронизации потоков разных 
процессов.

Получить дескриптор существующего объекта-события можно вызовом 
функции  CreateEvent, либо вызовом функции OpenEvent, указав в 
параметре pszName имя существующего объекта.

HANDLE OpenEvent(
	DWORD dwDesiredAccess,	// права доступа (EVENT_ALL_ACCESS –
							//полный доступ)
	BOOL blnheritHandle,	// параметр определяет, будет ли 
							// наследоваться
							// дескриптор события (если TRUE – 
							// дескриптор наследуемый)
	LPCTSTR pszName			// имя объекта
);

Создав событие, существует возможность напрямую управлять его 
состоянием.  

Для перевода события в свободное состояние используется функция API  
SetEvent.

BOOL SetEvent(
	HANDLE hEvent // дескриптор объекта ядра «событие»
);

Для перевода события в занятое состояние используется функция API 
ResetEvent.

BOOL ResetEvent(
	HANDLE hEvent // дескриптор объекта ядра «событие»
);

Следует отметить, что для событий с автоматическим сбросом действует 
следующее правило. 

Когда ожидание потоком освобождения события успешно завершается, 
то объектсобытие  автоматически сбрасывается в занятое состояние. 

Для событий со сбросом вручную автоматического сбрасывания не 
происходит, поэтому для возврата в занятое состояние необходимо 
вызвать функцию ResetEvent.

Функция API PulseEvent, которая также может использоваться для 
управления состоянием события.

BOOL PulseEvent(
	HANDLE hEvent // дескриптор объекта ядра «событие»
);

Функция PulseEvent освобождает событие и тут же переводит его 
обратно в занятое состояние. 

Вызов данной функции равнозначен последовательному вызову функций
SetEvent и ResetEvent. При вызове функции PulseEvent для события 
со сбросом вручную, любые потоки, ждущие этот объект, становятся 
планируемыми. 

При вызове этой функции применительно к событию с автоматическим 
сбросом пробуждается только один из ждущих потоков.
*/
// Пример


// 2.	Таймер синхронизации
/*
Таймер синхронизации или ожидаемый таймер (waitable timer) - это 
объект ядра, который самостоятельно переходит в свободное состояние 
в определенное время или через регулярные промежутки времени.

Ожидаемый таймер аналогично событию бывают двух типов:
	•	со сбросом вручную;
	•	с автоматическим сбросом.

Таймер с ручным сбросом позволяют возобновить выполнение сразу 
нескольких ждущих потоков, в то время как таймер с автоматическим
сбросом  возобновляют выполнение только одного потока.

Для создания таймера синхронизации необходимо вызвать функцию API 
CreateWaitableTimer.

HANDLE CreateWaitableTimer(
	LPSECURITY_ATTRIBUTES psa,	// атрибуты доступа
	BOOL bManualReset,			// тип сброса
	LPCTSTR pszName				// имя объекта
);

Параметр bManualReset определяет тип таймера синхронизации. 
Значение TRUE  создает таймер со сбросом вручную, а значение 
FALSE — таймер с автоматическим сбросом. 

Параметр pszName содержит указатель на строку, в которой содержится 
имя объекта синхронизации. 

Если pszName имеет значение NULL, то создается неименованный объект.

Получить дескриптор существующего таймера синхронизации можно 
вызовом функции  API OpenWaitableTimer, указав в параметре pszName
имя существующего объекта.

HANDLE OpenWaitableTimer(
DWORD dwDesiredAccess,		// права доступа (TIMER_ALL_ACCESS – полный доступ)
	BOOL blnheritHandle,	// параметр определяет, будет ли  наследоваться
							// дескриптор таймера (если TRUE – дескриптор наследуемый)
	LPCTSTR pszName			// имя объекта
);

Объект «ожидаемый таймер» всегда создаются в занятом состоянии. 
Чтобы сообщить таймеру, в какой момент он должен перейти в свободное
состояние, необходимо вызвать функцию API SetWaitableTimer.

BOOL SetWaitableTimer(
	HANDLE hTimer,					// дескриптор таймера
	const LARGE_INTEGER pDueTime,	// время первого срабатывания 
									// таймера
	LONG lPeriod,					// период таймера в миллисекундах
	PTIMERAPCROUTINE pfnCompletionRoutine,// адрес асинхронно вызываемой                  // APC-процедуры (asynchronous procedure call), которая вызывается в момент // перехода таймера в сигнальное состояние
	LPVOID lpArgToCompletionRoutine,// указатель на структуру, 
									// передаваемую в 
									// APC-процедуру
	BOOL fResume					// если данный параметр равен
									// TRUE, при срабатывании таймера 
									// компьютер выйдет из режима сна
									// (если он находился в спящем 
									// режиме), и    
									// возобновятся потоки, ожидавшие
									// этот таймер.
);

Параметры pDueTime и lPeriod используются совместно: первый из них 
задает, когда таймер должен сработать в первый раз, второй определяет,
насколько часто это должно происходить в дальнейшем.

Следует отметить, что чаще всего необходимо, чтобы таймер сработал
только один раз - через определенное время перешел в свободное
состояние и уже больше никогда не срабатывал. Для этого достаточно
передать 0 в параметре lPeriod. Затем можно вызвать CloseHandle,
чтобы закрыть таймер, либо перенастроить таймер по-вторным вызовом
SetWaitableTimer с другими параметрами.

Для отмены ожидаемого таймера применяется функция API 
CancelWaitableTimer.

BOOL CancelWaitableTimer(
	HANDLE hTimer // дескриптор таймера синхронизации
);
*/
// пример

int _tmain(int argc, _TCHAR* argv[])
{
	return 0;
}

