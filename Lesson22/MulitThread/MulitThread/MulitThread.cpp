// MulitThread.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <Windows.h>
#include <windowsx.h>

// Повторение пройденного материала
/*
    1.	Что такое многозадачность?
    2.	Что такое процесс? Из каких компонент состоит процесс?
    3.	Какая функция API позволяет создать процесс?
    4.	Какие существуют способы завершения процесса?
    5.	Какой способ завершения процесса считается наиболее 
        корректным?
    6.	Что такое объект ядра?
    7.	Для чего в объекте ядра необходим счётчик пользователей?
    8.	Что такое дочерний процесс?
    9.	Какой механизм позволяет нескольким процессам совместно 
        использовать дескриптор объекта ядра?
    10.	Какая функция API позволяет закрыть описатель объекта ядра?
    11.	Что такое снимок системы?
    12.	Посредством какой функции библиотеки Tool Help API  
        можно получить снимок системы ?
    13.	Какие функции библиотеки Tool Help API  позволяют получить 
        список запущенных процессов из снимка системы ?
    14.	Какая функция API используется для получения описателя 
        процесса по его идентификатору ?
*/

// 1.	Потоки.Основные сведения
/*
При запуске любого приложения операционная система Windows создает 
процесс. При этом процесс сам по себе не выполняется.

При инициализации процесса система создает в нем единственный поток, 
который называется первичным или основным потоком.

Первичный поток исполняет код программы, манипулируя данными в 
адресном пространстве процесса.

Из основного потока при необходимости могут быть запущены один или 
несколько вторичных потоков, которые выполняются одновременно с 
основным потоком.

В этой связи открывается возможность  написания многопоточных 
приложений, что позволяет программисту более полно и тонко управлять 
ходом выполнения как программы в целом, так и отдельных ее частей.

Это дает возможность создавать более эффективные приложения.

Например, в одном потоке можно решать задачу сортировки данных, 
в другомсбора информации от удаленных источников, а в третьем - 
задачу обработки информации, вводимой пользователем.

Таким образом, написание многопоточных приложений может значительно 
повысить их производительность за счет более эффективного 
распределения ресурсов компьютера.

Это становится особенно актуальным при применении многопроцессорных 
систем или систем с несколькими ядрами в одном процессоре, поскольку 
позволяет выполнить несколько потоков одновременно.

Поскольку потоки всегда создаются в контексте какого - либо процесса, 
все они разделяют адресное пространство того процесса, в котором были
созданы.

Следует отметить, что поток, также как и процесс, состоит из двух 
компонент:
    1)	объект ядра «поток» - структура данных Windows, через которую
        система управляет потоком. В ней хранится статистическая 
        информация о потоке;
    2)	стек потока, который содержит параметры всех функций и 
        локальные переменные, необходимые потоку для выполнения 
        кода.
*/

// 3.	Потоки и WinAPI

// 3.1  Создание потока
/*
    Каждый поток начинает выполнение с некоторой входной функции.
    В первичном потоке используется функция WinMain. Если необходимо 
    создать вторичный поток, в нем тоже должна быть входная функция, 
    имеющая следующий прототип:

    DWORD WINAPI ThreadProc (
        LPVOID lpParameter		// аргумент, передаваемый в функцию 
                                // при создании вторичного потока
    );

    Следует подчеркнуть, что потоковая функция может выполнять 
    различные задачи. После завершения своей работы функция потока 
    вернет управление.
    
    В этот момент поток остановится, память, отведенная под его стек, 
    будет освобождена, а счетчик пользователей объекта ядра «поток» 
    уменьшится на единицу. Когда счетчик обнулится, этот объект ядра 
    будет разрушен.

    Как отмечалось ранее, первичный поток создается системой при 
    запуске исполняемого файла либо при создании дочернего процесса 
    вызовом функции API CreateProcess. Для создания вторичных потоков 
    необходимо воспользоваться функцией API CreateThread, которая 
    создает новый поток в адресном пространстве процесса.

    HANDLE CreateThread(
        LPSECURITY_ATTRIBUTES lpThreadAttributes, // указатель на структуру,
                                                  // описывающую параметры 
                                                  // защиты потока. Если 
                                                  // параметру присвоено
                                                  // значение NULL, то 
                                                  // устанавливаются атрибуты 
                                                  // по умолчанию.
        DWORD dwStackSize,						  // устанавливает размер 
                                                  // стека, который отводится
                                                  // потоку. Если параметр 
                                                  // равен нулю, то устанавливается
                                                  // стек, равный стеку 
                                                  // первичного потока
        LPTHREAD_START_ROUTINE lpStartAddress,    // адрес входной потоковой
                                                  // функции
        LPVOID lpParameter,                       // параметр, передаваемый 
                                                  // в потоковую функцию
        DWORD dwCreationFlags,					  // флаг, который управляет
                                                  // созданием потока.
                                                  // Если этот параметр 
                                                  // равен CREATE_SUSPENDED,
                                                  // то поток после порождения 
                                                  // не  запускается на 
                                                  // исполнение.
        LPDWORD lpThreadId						  // адрес переменной типа 
                                                  // DWORD, в которую функция  
                                                  // возвращает идентификатор 
                                                  // нового потока
    );
    https://msdn.microsoft.com/en-us/library/windows/desktop/ms682453(v=vs.85).aspx
*/

// Ожидание завершения выполнения потоков
/*
    Ожидание завршения одиночного потока

    DWORD WINAPI WaitForSingleObject(
        _In_ HANDLE hHandle,			// 
        _In_ DWORD  dwMilliseconds		// 
    );
    https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx

    Ожидание завершения множества процессов

    DWORD WINAPI WaitForMultipleObjects(
        _In_       DWORD  nCount,
        _In_ const HANDLE *lpHandles,
        _In_       BOOL   bWaitAll,
        _In_       DWORD  dwMilliseconds
    );
*/

// 3.2 Завершение потока
/*
    Способы завершения потока:
    •	функция потока возвращает управление (рекомендуемый способ);
    •	поток самоуничтожается вызовом функции ExitThread;
    •	один из потоков данного или другого процесса вызывает функцию 
        TerminateThread;
    •	завершается процесс, содержащий данный поток.

    При разработке приложения желательно, чтобы поток завершался только 
    после возврата управления потоковой функцией. Это единственный способ, 
    гарантирующий корректную очистку всех ресурсов, принадлежавших потоку.


    VOID ExitThread(
        UINT uExitCode // код завершения потока
    );

    BOOL TerminateThread(
        HANDLE hThread, // дескриптор завершаемого потока
        UINT uExitCode  // код завершения потока
    );

    Поток можно приостановить на  определенный период времени, вызвав 
    функцию API Sleep.

    VOID Sleep(
        DWORD dwMilliseconds // длительность временной задержки в 
                             // миллисекундах
    );
*/

DWORD WINAPI ThreadProc(LPVOID lParam)
{
    TCHAR* text = (TCHAR*)lParam;
    for (int i = 0; i < 10; i++)
    {
        _tprintf(TEXT("%s\n"),text);
        Sleep(1000);
    }
    return 0;
}

// Демо многопоточных приложений
void ex01()
{
    HANDLE t[3] = { 0 };
    t[0] = CreateThread(0, 0, ThreadProc, TEXT("Thread 1"), 0, NULL);
    t[1] = CreateThread(0, 0, ThreadProc, TEXT("Thread 2"), 0, NULL);
    t[2] = CreateThread(0, 0, ThreadProc, TEXT("Thread 3"), 0, NULL);
    WaitForMultipleObjects(3, t, TRUE, INFINITE);
    for (int i = 0; i < 3; i++)
    {
        CloseHandle(t[i]);
    }
}

// 3.3 Приостановка и возобновление работы потоков
/*
    В объекте ядра «поток» имеется  счетчик числа приостановок данного потока. 
    
    При вызове функции CreateThread он инициализируется значением, равным 1, 
    которое запрещает системе выделять новому потоку процессорное время. 
    
    Это обусловлено тем, что сразу же после создания поток ещё не готов к 
    выполнению и ему необходимо время для инициализации. 
    
    После того как поток полностью инициализирован, функция CreateThread 
    проверяет, не передан ли ей флаг CREATE_SUSPENDED. Если данный флаг 
    был указан, функция возвращает управление, оставив созданный поток в 
    приостановленном состоянии. 
    В ином случае счетчик приостановок обнуляется, и поток начинает 
    выполняться.

    Выполнение отдельного потока можно приостанавливать несколько раз. 
    Если поток был приостановлен 3 раза (в этом случае счётчик приостановок 
    равен 3), то и возобновить его следует тоже 3 раза, чтобы обнулить 
    счётчик приостановок — лишь тогда система выделит потоку процессорное 
    время.
    
    Для приостановки («усыпления») потока служит функция API SuspendThread:

    DWORD SuspendThread(
        HANDLE hThread // дескриптор потока
    );
    https://msdn.microsoft.com/en-us/library/windows/desktop/ms686345(v=vs.85).aspx

    В случае успешного выполнения данная функция увеличивает на единицу 
    счетчик приостановок, возвращая его предыдущее значение.
    
    Для возобновления работы потока служит функция API ResumeThread:

    DWORD ResumeThread(
        HANDLE hThread // дескриптор потока
    );
    https://msdn.microsoft.com/en-us/library/windows/desktop/ms685086(v=vs.85).aspx

    В случае успешного выполнения данная функция уменьшает на единицу 
    счетчик приостановок, возвращая предыдущее значение счетчика.
*/

// Демо приложения

// 4. Принципы работы с приоритетами потоков
/*
Операционная система выделяет каждому потоку определенное 
процессорное время. Тем самым для однопроцессорной системы 
создается иллюзия одновременного выполнения потоков. 

При этом в любой момент времени только один поток  может 
находиться в состоянии выполнения. Все остальные потоки находятся
либо в состоянии готовности, либо в состоянии блокировки.

Следует подчеркнуть, что важным моментом в реализации многоза-
дачности является организация очереди готовых к выполнению 
потоков. 

В Windows реализована система вытесняющего планирования на основе 
приоритетов. Это означает, что освободившийся процессор продолжает
обслуживать тот поток из очереди, который обладает наибольшим 
приоритетом. При этом суммарный приоритет потока складывается из 
двух составляющих: 
    - класса  приоритета процесса, его создавшего, и 
    - относительного приоритета потока внутри этого класса.

Windows поддерживает 32 приоритета (от 0 до 31) — чем больше 
номер, тем выше приоритет

____________________________________________________________________________
Относительный приоритет	 |	Idle  |	Класс приоритета процесса       |
        потока			 |        |---------------------------------| Real
                         |        | Below  | Normal | Above  | High | -time
                         |		  |	normal |        | normal |      |
_________________________|________|________|________|________|______|________
      Time-critical		 |        |        |        |        |      |
(критичный по времени)		15		  15	   15		15		15		31
_________________________|________|________|________|________|______|________
Highest (высший) 			6		   8	   10		12		15		26
_________________________|________|________|________|________|______|________
Above normal			 |        |        |        |        |      |
(выше обычного) 			5		   7	    9		11		14		25
_________________________|________|________|________|________|______|________
Normal (обычный) 			4		   6		8		10		13		24
_________________________|________|________|________|________|______|________
Below normal             |        |        |        |        |      |
(ниже обычного) 			3		   5		7		9		12		23
_________________________|________|________|________|________|______|________
Lowest (низший) 			2		   4		6		8		11		22
_________________________|________|________|________|________|______|________
Idle (простаивающий) 		1		   1		1		1		 1		16
_________________________|________|________|________|________|______|________

Классы Below normal и Above normal стали использоваться, начиная с Windows 2000.
Класс Idle назначается процессу, который должен простаивать в случае  активности
других процессов (например, приложение «Хранитель экрана»).

Процессам, которые запускает пользователь, присваивается класс Normal. 
Это самые многочисленные процессы в системе, и, как правило, они интерактивны 
– требуют постоянного взаимодействия с пользователем (например, графические 
или текстовые редакторы).  Процессы класса Normal делятся на процессы переднего 
плана (foreground) и фоновые (background). Для процесса, с которым пользователь 
в данный момент работает, то есть для процесса  переднего плана, уровень 
приоритета поднимается на две единицы. Это повышает уровень комфорта работы с 
программой.

Создавать процессы, относящиеся к классу High, следует с особой  осторожностью.
Если поток с классом приоритета High занимает процессор достаточно долго, 
то в это время другие потоки вообще не получат доступа к процессору. 
Обычно с классом High работают некоторые системные процессы, которые большую 
часть времени ожидают какого-либо события (например, winlogon.exe).

Не желательно использовать класс приоритета Realtime, поскольку в этом случае 
приложение будет прерывать системные потоки, управляющие мышью, клавиатурой и 
дисковыми операциями – фактически система будет парализована. Только в особых 
случаях, когда программа взаимодействует непосредственно с аппаратурой или 
решаются короткие подзадачи, для которых нужно гарантировать отсутствие 
прерываний, класс приоритета Realtime может быть кратковременно использован.

Для изменения класса приоритета процесса во время работы  приложения может 
применяться функция API SetPriorityClass.

BOOL SetPriorityClass(
    HANDLE hProcess,// дескриптор процесса
    DWORD dwPriorityClass // класс приоритета процесса
);

Второй параметр может принимать следующие значения:

============================================================================
Класс приоритета процесса	Базовый уровень      Значение параметра
    приоритета									
============================================================================
       Idle							4			IDLE_PRIORITY_CLASS
    Below normal					6			BELOW_NORMAL_PRIORITY_CLASS
     Normal							8			NORMAL_PRIORITY_CLASS
    Above normal					10			ABOVE_NORMAL_PRIORITY_CLASS
       High							13			HIGH_PRIORITY_CLASS
     Realtime						24			REALTIME_PRIORITY_CLASS
============================================================================

Для получения класса приоритета процесса используется функция 
API GetPriorityClass.

DWORD GetPriorityClass(
    HANDLE hProcess,// дескриптор процесса
);

По умолчанию создаваемый поток получает базовый приоритет в соответствии с 
классом своего процесса. После создания потока его относительный приоритет 
может  изменяться как операционной системой, так и приложением с помощью 
функции API SetThreadPriority.

BOOL SetThreadPriority(
    HANDLE hThread,	// дескриптор потока
    int nPriority	// относительный приоритет потока
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms686277(v=vs.85).aspx

Второй параметр может принимать следующие значения:

Для получения относительного приоритета потока используется функ-ция API GetThreadPriority.

int GetThreadPriority(
HANDLE hThread // дескриптор потока
);

Для получения дескриптора текущего процесса используется функция API 
GetCurrentProcess.

    HANDLE GetCurrentProcess(void);

Для получения дескриптора текущего потока используется функция API 
GetCurrentThread.

    HANDLE GetCurrentThread(void);

Для получения идентификатора текущего процесса используется функция API 
GetCurrentProcessId.

    DWORD GetCurrentProcessId(void);

Для получения идентификатора текущего потока используется функция API 
GetCurrentThreadId.

    DWORD GetCurrentThreadId(void);
*/

// Демо приложения

// 5.	Локальная память потока (thread local storage, TLS)
/*
Статические переменные, как глобальные, так и локальные по отношению к 
функциям, разделяются между потоками, поскольку они расположены в области 
памяти данных процесса. В то же время автоматические локальные переменные 
всегда уникальны для каждого потока, поскольку они располагаются в стеке, 
а каждый поток имеет свой стек.

Иногда бывает удобно использовать для двух и более потоков одну и ту же 
функцию, но при этом, чтобы у каждого потока были уникальные 
статические данные. В этом случае возникает необходимость иметь постоянную 
область памяти, уникальную для каждого потока. Эта область памяти называется 
локальной памятью потока. Существуют два вида TLS:
    •	динамическая локальная память потока;
    •	статическая локальная память потока.

Приложение работает с динамической локальной памятью потока, оперируя 
набором из четырех функций.

Каждый флаг выполняемого в системе процесса может находиться в состоянии 
FREE или INUSE, указывая, свободна или занята данная область локальной 
памяти потока (TLS-область). Чтобы воспользоваться динамической локальной 
памятью потока, первичный поток должен вызывать сначала функцию 
API TlsAlloc для получения значения индекса:

        DWORD TlsAlloc();

Функция TlsAlloc заставляет систему сканировать битовые флаги в текущем 
процессе и искать флаг FREE. Отыскав, система меняет его на INUSE, а 
TlsAlloc возвращает индекс флага в битовом массиве. Индекс может храниться
в глобальной переменной или может быть передан функции потока в 
параметре структуре.
    
Создавая поток, система создает и массив из TLS_MINIMUM_AVAILABLE элементов 
- значений типа PVOID (иденти-фикатор TLS_MINIMUM_AVAILABLE определен в 
файле WinNT.h как 64). При этом система инициализирует массив нулями и 
сопоставляет с потоком. Таким массивом, элементы которого могут принимать 
любые значения, располагает каждый поток. Прежде чем сохранить что-то в 
PVOID-массиве потока, необходимо выяснить, какой индекс в нем до-ступен, 
- для этой цели и служит предварительный вызов TlsAlloc.

Чтобы занести в массив потока значение, необходимо воспользоваться 
функцией API TlsSetValue.

    BOOL TlsSetValue(
        DWORD dwTlsIndex,// TLS-индекс, возвращаемый функцией TlsAlloc
        PVOID pvTlsValue // значение типа PVOID
    );

Данная функция помещает в элемент массива, индекс которого определяется 
параметром dwTlsIndex, значение типа PVOID, содер-жащееся в параметре 
pvTlsValue. Содержимое сопоставляется с пото-ком, вызвавшим TlsSetValue. 
В случае успеха возвращается TRUE.

Для чтения значений из массива потока служит функция API TlsGetValue.

    PVOID TlsGetValue(
        DWORD dwTlsIndex // TLS-индекс, возвращаемый функцией TlsAlloc
    );

Данная функция возвращает значение, сопоставленное с TLS-областью под 
индексом dwTlsIndex. Как и TlsSetValue, функция TlsGetValue обращается 
только к массиву, который принадлежит вызывающему потоку.
    
Когда необходимость в TLS-области у всех потоков в процессе отпадет, 
необходимо вызвать функцию TlsFree.

    BOOL TlsFree(
        DWORD dwTlsIndex // TLS-индекс, возвращаемый функцией TlsAlloc
    );

Эта функция просто сообщит системе, что данная область больше не нужна. 
Флаг INUSE, управляемый массивом битовых флагов про-цесса, установится как FREE.
Далее следует в общих чертах рассмотреть работу статической локальной памяти 
потока. Необходимо отметить, что статическая TLS основана на той же концепции, 
что и динамическая, - статическая локальная память потока предназначена для 
того, чтобы с потоком можно было сопоставить те или иные данные. Однако 
статическую локальную память потока использовать гораздо проще, так как при 
этом не нужно обращаться к каким-либо функциям.
Работа статической TLS-памяти строится на тесном взаимодействии с операционной 
системой.  Загружая приложение в память, система отыскивает в ЕХЕ-файле раздел
.tls (в данном разделе расположены все TLS-переменные) и динамически выделяет
блок памяти для хране-ния всех статических TLS-переменных.  Всякий раз, когда
приложение ссылается на одну из таких переменных, ссылка переадресуется  к
участку, расположенному в выделенном блоке памяти. В итоге компи-лятору
приходится генерировать дополнительный код для ссылок на статические 
TLS-переменные, что увеличивает размер приложения и замедляет скорость его 
работы.

Если в процессе создается другой поток, система выделяет еще один блок 
памяти для хранения статических переменных нового пото-ка.  Только что 
созданный поток имеет доступ лишь к своим статиче-ским TLS-переменным, 
и не может обратиться к TLS-переменным любо-го другого потока.

*/
int main()
{
    ex01();
    return 0;
}

