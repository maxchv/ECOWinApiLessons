// MulitThread.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Повторение пройденного материала
/*
	1.	Что такое многозадачность?
	2.	Что такое процесс? Из каких компонент состоит процесс?
	3.	Какая функция API позволяет создать процесс?
	4.	Какие существуют способы завершения процесса?
	5.	Какой способ завершения процесса считается наиболее 
		корректным?
	6.	Что такое объект ядра?
	7.	Для чего в объекте ядра необходим счётчик пользователей?
	8.	Что такое дочерний процесс?
	9.	Какой механизм позволяет нескольким процессам совместно 
		использовать дескриптор объекта ядра?
	10.	Какая функция API позволяет закрыть описатель объекта ядра?
	11.	Что такое снимок системы?
	12.	Посредством какой функции библиотеки Tool Help API  
		можно получить снимок системы ?
	13.	Какие функции библиотеки Tool Help API  позволяют получить 
		список запущенных процессов из снимка системы ?
	14.	Какая функция API используется для получения описателя 
		процесса по его идентификатору ?
*/

// 1.	Потоки.Основные сведения
/*
При запуске любого приложения операционная система Windows создает 
процесс. При этом процесс сам по себе не выполняется.

При инициализации процесса система создает в нем единственный поток, 
который называется первичным или основным потоком.

Первичный поток исполняет код программы, манипулируя данными в 
адресном пространстве процесса.

Из основного потока при необходимости могут быть запущены один или 
несколько вторичных потоков, которые выполняются одновременно с 
основным потоком.

В этой связи открывается возможность  написания многопоточных 
приложений, что позволяет программисту более полно и тонко управлять 
ходом выполнения как программы в целом, так и отдельных ее частей.

Это дает возможность создавать более эффективные приложения.

Например, в одном потоке можно решать задачу сортировки данных, 
в другомсбора информации от удаленных источников, а в третьем - 
задачу обработки информации, вводимой пользователем.

Таким образом, написание многопоточных приложений может значительно 
повысить их производительность за счет более эффективного 
распределения ресурсов компьютера.

Это становится особенно актуальным при применении многопроцессорных 
систем или систем с несколькими ядрами в одном процессоре, поскольку 
позволяет выполнить несколько потоков одновременно.

Поскольку потоки всегда создаются в контексте какого - либо процесса, 
все они разделяют адресное пространство того процесса, в котором были
созданы.

Следует отметить, что поток, также как и процесс, состоит из двух 
компонент:
	1)	объект ядра «поток» - структура данных Windows, через которую
		система управляет потоком. В ней хранится статистическая 
		информация о потоке;
	2)	стек потока, который содержит параметры всех функций и 
		локальные переменные, необходимые потоку для выполнения 
		кода.
*/

// 3.	Потоки и WinAPI

// 3.1  Создание потока
/*
	Каждый поток начинает выполнение с некоторой входной функции.
	В первичном потоке используется функция WinMain. Если необходимо 
	создать вторичный поток, в нем тоже должна быть входная функция, 
	имеющая следующий прототип:

	DWORD WINAPI ThreadProc (
		LPVOID lpParameter		// аргумент, передаваемый в функцию 
								// при создании вторичного потока
	);

	Следует подчеркнуть, что потоковая функция может выполнять 
	различные задачи. После завершения своей работы функция потока 
	вернет управление.
	
	В этот момент поток остановится, память, отведенная под его стек, 
	будет освобождена, а счетчик пользователей объекта ядра «поток» 
	уменьшится на единицу. Когда счетчик обнулится, этот объект ядра 
	будет разрушен.

	Как отмечалось ранее, первичный поток создается системой при 
	запуске исполняемого файла либо при создании дочернего процесса 
	вызовом функции API CreateProcess. Для создания вторичных потоков 
	необходимо воспользоваться функцией API CreateThread, которая 
	создает новый поток в адресном пространстве процесса.

	HANDLE CreateThread(
		LPSECURITY_ATTRIBUTES lpThreadAttributes, // указатель на структуру,
												  // описывающую параметры 
												  // защиты потока. Если 
												  // параметру присвоено
												  // значение NULL, то 
												  // устанавливаются атрибуты 
												  // по умолчанию.
		DWORD dwStackSize,						  // устанавливает размер 
												  // стека, который отводится
												  // потоку. Если параметр 
												  // равен нулю, то устанавливается
												  // стек, равный стеку 
												  // первичного потока
		LPTHREAD_START_ROUTINE lpStartAddress,    // адрес входной потоковой
												  // функции
		LPVOID lpParameter,                       // параметр, передаваемый 
		                                          // в потоковую функцию
		DWORD dwCreationFlags,					  // флаг, который управляет
												  // созданием потока.
												  // Если этот параметр 
												  // равен CREATE_SUSPENDED,
												  // то поток после порождения 
												  // не  запускается на 
												  // исполнение.
		LPDWORD lpThreadId						  // адрес переменной типа 
		                                          // DWORD, в которую функция  
												  // возвращает идентификатор 
												  // нового потока
	);
*/

// 3.2 Завершение потока
/*
	Способы завершения потока:
	•	функция потока возвращает управление (рекомендуемый способ);
	•	поток самоуничтожается вызовом функции ExitThread;
	•	один из потоков данного или другого процесса вызывает функцию 
		TerminateThread;
	•	завершается процесс, содержащий данный поток.

	При разработке приложения желательно, чтобы поток завершался только 
	после возврата управления потоковой функцией. Это единственный способ, 
	гарантирующий корректную очистку всех ресурсов, принадлежавших потоку.


	VOID ExitThread(
		UINT uExitCode // код завершения потока
	);

	BOOL TerminateThread(
		HANDLE hThread, // дескриптор завершаемого потока
		UINT uExitCode  // код завершения потока
	);

	Поток можно приостановить на  определенный период времени, вызвав 
	функцию API Sleep.

	VOID Sleep(
		DWORD dwMilliseconds // длительность временной задержки в 
							 // миллисекундах
	);
*/

// Демо многопоточных приложений

// 4. Принципы работы с приоритетами потоков

int main()
{
    return 0;
}

