// Lesson05.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"

//Повторение пройденного материала
/*
1)	Каким образом в приложении можно установить таймер?
2)	Какие существуют способы обработки прерываний таймера?
3)	Каким образом таймер можно остановить?
4)	С помощью какой функции можно определить, какие приложения, 
	владеющие окном, выполняются в данное время?
5)	Каков принцип работы функции, перечисляющей окна верхнего уровня?
6)	Какая функция может применяться для последовательной обработки 
	дочерних окон?
7)	Каков принцип работы функции, перечисляющей дочерние окна?
8)	Какие объекты определяются в ресурсах приложения? Привести примеры.
9)	Что такое файл описания ресурсов(resource script)?
10)	Какая информация хранится в заголовочном файле resource.h?
11)	Чем отличается загрузка предопределённого ресурса от загрузки 
	нестандартного ресурса, определённого в приложении?
12)	Для какой цели используется  макрос MAKEINTRESOURCE?
13)	Какими способами можно получить дескриптор приложения в 
	оконной процедуре?
14)	Что такое пиктограмма(иконка)? Какие типовые размеры иконки 
	применяются чаще всего?
15)	Что такое курсор? С помощью какого инструмента можно назначить 
	активную точку?
16)	Какая функция позволяет  модифицировать оконный класс?
17)	Какая функция служит для  динамического изменения формы курсора 
	в зависимости от его местонахождения?
18)	Каким образом можно проконтролировать успешность работы функции API, 
	а также получить описание ошибки при её возникновении в результате 
	работы функции?
*/

// Создание диалогового приложения
// Создание приложения на основе модального диалога
void ex01()
{
	/*
		Приложение на основе модального диалога должно содержать 
		как минимум две функции:
		•	WinMain — главную функцию
		•	DlgProc — диалоговую процедуру
	*/

	// Создание модального диалога
	/*
		INT_PTR DialogBox(
			HINSTANCE hInstance,	// дескриптор экземпляра приложения, 
									// содержащего шаблон диалогового окна
			LPCTSTR lpTemplate,		// указатель на строку, содержащую 
									// имя шаблона диалогового окна
			HWND hWndParent,		// дескриптор родительского окна
			DLGPROC lpDialogFunc	// указатель на диалоговую процедуру
		);

		Функция выполняется до тех пор, пока диалоговая процедура не
		закроет модальное окно командой:
		
		BOOL EndDialog(
			HWND hDlg,		 // дескриптор диалогового окна
			INT_PTR nResult  // значение, возвращаемое функцией DialogBox
		);
	*/
	// Отличие диалоговой процедуры от оконной
	/*	
	•	Возвращает значение типа BOOL.
	•	Если диалоговая процедура не обрабатывает сообщение, 
	    то она возвращает значение FALSE (вызов стандартного обработчика
		сообщения).
	•	Если диалоговая процедура обрабатывает какое-то  сообщение, 
	    то она возвращает значение TRUE (запрет вызова стандартного 
		обработчика сообщения).
	•	Для закрытия диалогового приложения необходимо в диалоговой 
	    процедуре обработать сообщение WM_CLOSE.
	*/
}

// Создание приложения на основе немодального диалога
void ex02()
{
	//Немодальные диалоговые окна создаются при помощи функции
	/*
	HWND CreateDialog(
		HINSTANCE hInstance, // дескриптор экземпляра приложения, 
							 // содержащего шаблон диалогового окна
		LPCTSTR lpTemplate,  // указатель на строку, содержащую 
							 // имя шаблона диалогового окна
		HWND hWndParent,	 // дескриптор родительского окна
		DLGPROC lpDialogFunc // указатель на диалоговую процедуру
	);

	Функция CreateDialog DialogBox сразу же возвращает дескриптор 
	диалогового окна, не дожидаясь его закрытия.
	
	Для  того  чтобы немодальное окно появилось на экране необходимо 
	в свойствах шаблона диалогового окна установить значение True 
	для свойства Visible. 
	
	Другим способом отображения немодального окна является вызов 
	функции ShowWindow.
		
	В теле функции WinMain следует предусмотреть цикл обработки 
	сообщений.
	*/
	/*
	Для закрытия приложения, созданного на основе немодального 
	диалога, необходимо в диалоговой процедуре при обработке 
	сообщения WM_CLOSE вызать функцию DestroyWindow, и 
	остановить цикл обработки сообщений с помощью функции 
	PostQuitMessage	
	*/
}

// Общие сведения об элементах управления
void ex03()
{
	/*
		Windows поддерживает базовые элементы управления:
			- кнопки (Button)
			- флажки (Check Box)
			- переключатели (Radio Button)
			- списки (List Box)
			- окна ввода (Edit Control)
			- комбини-рованные списки (Combo Box)
			- статические элементы (Static Text)
			- полосы прокрутки (Scroll Bar)
			- рамки (Group Box)

		Общие элементы управления, включенные в библиотеку 
		элементов управления общего пользования 
		(common control library), также включает:
			- панель инструментов (Toolbar)
			- окно подсказки (Tooltip)
			- индикатор (Progress Control)
			- счётчик (Spin Control)
			- строка состояния (Status Bar) и другие.
	*/
	/*
		Каждый элемент управления реализуется в виде окна 
		соответствующего класса. 
		Например, все кнопки относятся к классу BUTTON. 
		Примерами других предопределённых классов для 
		элементов управления являются STATIC, LISTBOX, 
		EDIT, COMBOBOX и другие.
	*/
	/*
		Для создания элемента управления диалогового окна можно
		воспользоваться функцией CreateWindow.

		При этом случае во втором параметре функции передается 
		имя предопределенного оконного класса

		Пример:
			CreateWindowEx(0, TEXT("STATIC"), 0,
							WS_CHILD | WS_VISIBLE | WS_BORDER | 
							SS_CENTER |	WS_EX_CLIENTEDGE,	
							LEFT, TOP, WIDTH, HEIGHT, hWnd, 0, hInst, 0);
		
		Стили окна: https://msdn.microsoft.com/ru-ru/library/czada357.aspx
		Расширенные стили окна: https://msdn.microsoft.com/ru-ru/library/61fe4bte.aspx
		Статические стили: https://msdn.microsoft.com/ru-ru/library/9h0ay857.aspx		
	*/
	/*
	Элементы управления могут быть разрешенными (enabled) 
	или запрещенными (disabled). 
	
	Изменение статуса элементов управления осуществляется при 
	помощи функции EnableWindow:

		BOOL EnableWindow(
			HWND hWnd,   // дескриптор окна
			BOOL bEnable // если данный параметр равен TRUE, то окно будет
						 // разрешенным, в противном случае - запрещенным
	    );
	*/
}

// Статический элемент управления Static Text
void ex04()
{
	/*
	 Представляет собой средство описания чего-либо в диалоге и 
	 чаще всего просто отображается в виде текста.
	*/
	/*
	Свойства статического элемента управления Static Text:
	•	Caption содержит текстовую строку, которая будет отображаться внутри ограничивающего прямоугольника элемента Static Text. При этом в строке могут использоваться управляю-щие символы \t (табуляция) и \n (перевод строки).
	•	Border со значением True позволяет установить тонкую рамку вокруг элемента управления.
	•	Align text позволяет задать выравнивание текста по го-ризонтали. Можно использовать значение Left (по умолчанию), Center или Right.
	•	Center Image позволяет задать центрирование текста по вертикали.
	*/
}

// Статический элемент управления Picture Ctrl
void ex05()
{
	/*
	 PictureCtrl предназначен для размещения изображения на 
	 диалоговом окне.
	 
	 Прежде чем поместить изображение необходимо  сначала  
	 включить его в состав ресурсов проекта.
	 
	 После этого добавить на форму диалога элемент 
	 управления PictureCtrl.
	 */
}

//Практическая часть
/*
	Создать немодальное диалоговое приложение, позволяющее перемещать статик, 
	расположенного на форме диалога.
	
	Для перемещения статика следует использовать мышь.
*/

// Домашнее задание
/*
Разработать приложение, созданное на основе диалогового окна, 
и обладающее следующей функциональностью:

•	Пользователь «щелкает» левой кнопкой мыши по форме диалога и, 
    не отпуская кнопку, ведёт по ней мышку, а в момент отпускания 
	кнопки по полученным координатам прямоугольника
	(как известно, двух точек на плоскости достаточ - но для 
	создания прямоугольника) создаётся «статик», который содержит 
	свой порядковый номер (имеется в виду порядок появления «статика» 
	на форме).

•	Минимальный размер «статика» составляет 10х10, а при попытке 
    создания элемента управления меньших размеров пользователь должен 
	увидеть соответствующее предупреждение.

•	При щелчке правой кнопкой мыши над поверхностью «статика» в 
    заголовке окна должна появиться информация о статике (порядковый 
	номер «статика», ширина и высота, а также координаты «статика» 
	относительно родительского окна).
	В случае если в точке щелчка находится несколько «статиков», 
	то предпочтение отдается «статику» с наибольшим порядковым номером.

•	При двойном щелчке левой кнопки мыши над поверхностью «статика» 
    он должен исчезнуть с формы (для этого можно воспользоваться 
	функцией DestroyWindow, вызывая её для соответствующего объекта 
	«статика»).
	В случае если в точке щелчка находится несколько «статиков», 
	то предпочтение отдается «статику» с наименьшим порядковым номером.

	При разработке приложения рекомендуется использовать библиотеку STL.
*/


int main(int argc, TCHAR* argv[])
{
	return 0;
}

