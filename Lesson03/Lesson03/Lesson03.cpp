// Lesson03.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include <bitset>
#include <Windows.h>
using namespace std;

// Повторение пройденного материала
/*
1)	Для какой цели служит утилита Spy++ ?
2)	Почему рекомендуется использование венгерской нотации при именовании переменных ?
3)	Чем отличается спецификация __cdecl от __stdcall (WINAPI, CALLBACK) ?
4)	Какова структура минимального WinAPI - приложения ?
5)	Какие основные действия выполняются в главной функции программы ?
6)	Какие действия выполняются в цикле обработки сообщений, и при каком условии этот цикл прерывается ?
7)	Какую роль в приложении играет оконная процедура ?
8)	Что такое функция обратного вызова(CALLBACK–функция) ?
9)	Какое значение должна вернуть оконная процедура, если она выполняет обработку сообщения ?
10)	Какое значение должна вернуть оконная процедура, если для сообщения обработка не выполняется ?
11)	Что такое окно сообщения ?
*/

// Принципы обработки сообщений мыши
void ex01()
{
	// Сообщение мыши
	/*
		WM_LBUTTONDOWN – нажата левая кнопка мыши;
		WM_MBUTTONDOWN  - нажата средняя кнопка мыши;
		WM_RBUTTONDOWN – нажата правая кнопка мыши;
		WM_LBUTTONUP – отпущена левая кнопка мыши;
		WM_MBUTTONUP – отпущена средняя кнопка мыши;
		WM_RBUTTONUP – отпущена правая кнопка мыши.
		WM_LBUTTONDBLCLK – двойной щелчок левой кнопкой мыши;
		WM_MBUTTONDBLCLK – двойной щелчок средней кнопкой мыши;
		WM_RBUTTONDBLCLK - двойной щелчок правой кнопкой мыши.
		WM_MOUSEWHEEL - прокрутка колесика вызывает сообщение.

		Для всех этих сообщений значение параметра lParam содержит положение мыши. 
		При этом в младшем слове (младшие 2 байта) находится значение координаты х, 
		а в старшем слове (старшие 2 байта) — значение координаты у.

		Эти значения можно извлечь из lParam при помощи макросов 
		LOWORD и HIWORD.
		
		https://msdn.microsoft.com/en-us/library/windows/desktop/ms645607(v=vs.85).aspx
		
		Important  Do not use the LOWORD or HIWORD macros to extract the x- and y- coordinates of the cursor 
		position because these macros return incorrect results on systems with multiple monitors. 
		Systems with multiple monitors can have negative x- and y- coordinates, and LOWORD and HIWORD treat 
		the coordinates as unsigned quantities.
		
		As noted above, the x-coordinate is in the low-order short of the return value; the y-coordinate is in 
		the high-order short (both represent signed values because they can take negative values on systems with 
		multiple monitors). If the return value is assigned to a variable, you can use the MAKEPOINTS macro to obtain a 
		POINTS structure from the return value. You can also use the GET_X_LPARAM or GET_Y_LPARAM macro to extract the 
		x- or y-coordinate. 
		
		POINTS MAKEPOINTS(
		   DWORD dwValue
		);
		
		typedef struct tagPOINTS {
		  SHORT x;
		  SHORT y;
		} POINTS, *PPOINTS;
	*/
	// Пример: Закодировать в одном 32 битном целом два 16 битных числа
	int lParam;
	short x = 10;
	short y = 20;
	
	lParam = y;	
	cout << lParam << "y " << bitset<32>(lParam) << endl;
	lParam = lParam << 16;
	cout << lParam << " " << bitset<32>(lParam) << endl;
	cout << "x "<< y << " " << bitset<32>(x) << endl;
	lParam = lParam | x;
	cout << lParam << " " << bitset<32>(lParam) << endl;
	
	int hWord = HIWORD(lParam); //(lParam >> 16) & 0xffff;
	int lWord = LOWORD(lParam); // lParam & 0xffff;	
	
	cout << hWord << " " << lWord << endl;/**/
}

// Модификация стиля класса окна 
void ex02()
{	
	// Сообщения о двойном щелчке будут получены только в том случае,
	// если стиль соответствующего класса окна содержит флаг CS_DBLCLKS
	// 
	// Поэтому перед регистрацией класса окна нужно  присвоить полю style
	// флаг CS_DBLCLKS или изменить стиль перед отображением окна

	
	// Задать стиль окна
	/*
	DWORD SetClassLong(
		HWND hWnd,		// дескриптор окна
		int nIndex,		// значение, определяющее, что нужно изменить, например:
						// GCL_STYLE – изменить стиль окна,
						// GCL_HICON – изменить дескриптор курсора,
						// GCL_HCURSOR – изменить дескриптор иконки
		LONG dwNewLong	// новое 32-битное значение
	);

	*/

	// Получить стиль окна
	/*
	DWORD GetClassLong(
		HWND hWnd, // дескриптор окна
		int nIndex // значение, определяющее, что нужно получить из WNDCLASSEX
		);
	*/

	// Пример изменения стиля класса окна :
	/*
		UINT style = GetClassLong(hWnd, GCL_STYLE);
		SetClassLong(hWnd, GCL_STYLE, style | CS_DBLCLKS);
	*/
}


// Принципы обработки нажатия клавиш
void ex03()
{
	// Сообщения:
	//		WM_KEYDOWN	- клавиша только что нажата
	//		WM_CHAR		- клавиша нажата
	//		WM_KEYUP	- клавиша только что отпущена
	//

	// При получении сообщения WM_CHAR дополнительная информация
	// передается в параметрах:
	//
	//		1) wParam содержит ASCII-код нажатой клавиши
	//
	//		2) LOWORD (lParam) содержит количество повторов, 
	//						генерируемых при удерживании клавиши 
	//						в нажатом положении
	//
	//		3) HIWORD (lParam) представляет собой битовую карту: 
	//			•	15:  равен 1, если клавиша отпущена, и 0, если она нажата.
	//			•	14:  устанавливается, если клавиша уже была нажата перед 
	//					 посылкой сообщения.
	//			•	13:  устанавливается в 1, если дополнительно нажата 
	//                   клавиша <Alt>.
	//			•	12 - 9 : используется системой.
	//			•	8 :  устанавливается в 1, если нажата клавиша 
	//                   функциональной или дополнительной части клавиатуры.
	//			•	7 - 0 : код клавиши (scan - код).
	
	// При перехвате сообщений WM_KEYDOWN и WM_KEYUP в wParam содержатся 
	// виртуальные коды для клавиш управления курсором, клавиш <Shift>,<Ctrl>,
	// <Alt> функциональных клавиш (VK_LEFT, VK_DOWN, VK_SHIFT, VK_CTRL, 
	// VK_MENU, VK_RETURN, VK_TAB и т.д.). 
	// 
	// Получить состояние указанной виртуальной клавиши можно с помощью
	// функции API GetKeyState.
	//
	//	SHORT GetKeyState(int nVirtKey);
	//	
	// Параметр nVirtKey задаёт код виртуальной клавиши.
	// Возвращаемое значение – состояние клавиши, которое закодировано 
	// в двух битах.
	// Если старший бит равен 1, то клавиша нажата, в ином случае, она отпущена.
	// Если младший бит равен 1, то клавиша переключена, 
	// т.е.переведена во включенное состояние.
}

// Вывод текста в окно
void ex04()
{
	// Отрисовка окна происходит при перехвате сообщения WM_PAINT
	
	// В Windows все функции, выводящие что-либо в окно, используют 
	// в качестве параметра дескриптор контекста устройства hdc, 
	// который представляет собой структуру типа HDC, описывающую свойства 
	// данного устройства вывода. 
	// Для получения контекста устройства используется функция:
	// 
	// HDC WINAPI BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
	//
	//		
	//		struct PAINTSTRUCT {
	//			HDC hdc; //Контекст устройства
	//			BOOL fErase; //Если TRUE — фон окна перерисовывается
	//			RECT rcPaint; //Не действительный прямоугольник
	//			BOOL tRestore; // Резерв
	//			BOOL fIncUpdate; //Резерв
	//			BYTE rgbReserved[32]; //Резерв
	//		};
	
	//  Завершает обработчик сообщения функция EndPaint():
	/*	
		BOOL WINAPI EndPaint(HWND hWnd, CONST PAINTSTRUCT *lpPaint);
		
		которая обеспечивает освобождение контекста устройства.
	*/

	// Выводить текст в окно можно с помощью функции Textout():
	//
	// BOOL WINAPI TextOutW(HDC hdc, int x, int y, LPCWSTR str, int len);

	// Когда необходимо перерисовать окно, его объявляют недействительным. 
	// Для этого имеется функция InvalidateRect():
	// 
	// BOOL WINAPI InvalidateRect(HWND hWnd, CONST RECT *lpRect, BOOL bErase);
	//
	// которая объявляет недействительный прямоугольник *lpRect в окне hWnd.
	// Если вторым параметром указать NULL, то это приведет к перерисовке 
	// всего окна.
	// Значение TRUE третьего параметра является указанием перерисовать 
	// фон окна.
}

// Работа с окнами
void ex05()
{
	// Вывод строки в заголовок окна
	/*
	BOOL SetWindowText (
		HWND hWnd,		 // дескриптор окна, в котором должен быть изменен текст
		LPCTSTR lpString //указатель на строку, содержащую новый текст
	);
	*/

	// GetWindowRect позволяет получить размеры прямоугольника окна
	/*
	BOOL GetWindowRect(
		HWND hWnd,		//дескриптор окна
		LPRECT lpRect	//указатель на структуру RECT
	);
	*/

	// GetClientRect позволяет получить размеры прямоугольника, 
	// охватывающего клиентскую (рабочую) область окна
	/*
	BOOL GetClientRect(
		HWND hWnd,		//дескриптор окна
		LPRECT lpRect	//указатель на структуру RECT
	);

	*/

	// MoveWindow позволяет переместить окно, а также изменить его размеры
	/*
	BOOL MoveWindow(
		HWND hWnd,//дескриптор окна
		int X, //новая координата Х левого верхнего угла окна
		int Y, //новая координата Y левого верхнего угла окна

		int nWidth, //новая ширина окна
		int nHeight, //новая высота окна
		BOOL bRepaint //необходимость немедленной перерисовки окна
	);
	*/

	// BringWindowToTop активизирует окно и переносит его в верхнее положение, 
	// если оно находится позади других окон
	/*
	BOOL BringWindowToTop(
		HWND hWnd //дескриптор окна
	);
	*/

	// FindWindow поиска  окна  верхнего  уровня
	/*
	HWND FindWindow(
		LPCTSTR lpClassName, //имя класса окна
		LPCTSTR lpWindowName // заголовок окна
	);
	*/

	// FindWindowEx, которая служит для поиска дочерних окон (например, 
	// для поиска элементов управления диалогового окна)
	/*
	HWND FindWindowEx(
		HWND hwndParent,		//дескриптор родительского окна
		HWND hwndChildAfter,	//дескриптор дочернего окна, после которого следует
		                        //начать поиск, либо 0 – для поиска, 
								//начиная с первого дочернего окна
		LPCTSTR lpszClass,		//имя класса окна
		LPCTSTR lpszWindow		//заголовок окна
	);

	*/
}


// Практическое задание
/*
1)	Написать приложение, в котором ведётся подсчёт количества «кликов» левой, 
    правой и средней кнопки мыши. Обновляемую статистику необходимо выводить в заголовок окна.
2)	Предположим, что существует прямоугольник, границы которого на 10 пикселей отстоят от 
    границ клиентской области окна. Необходимо при нажатии левой кнопки мыши выводить в заголовок
	окна сообщение о том, где произошел щелчок мышью: внутри прямоугольника, снаружи или на границе 
	прямоугольника. При нажатии правой кнопки мыши необходимо выводить в заголовок окна информацию
	о размере клиентской области окна (ширина и высота клиентской области окна).
*/

// Домашенее задание
/*
1)	Написать приложение, позволяющее при нажатии левой кнопки мыши изменить текст в заголовке 
	окна стандартного приложения «Калькулятор», а при нажатии правой кнопки мыши сместить 
	вправо кнопку «пуск».

2)	Написать приложение, обладающее следующей функциональностью:
	•	при нажатии кнопки <Enter> окно позиционируется в левый верхний угол 
		экрана с размерами (300Х300);
	•	с помощью клавиш управления курсором осуществляется перемещение окна.
*/

int main()
{
	ex01();
    return 0;
}

