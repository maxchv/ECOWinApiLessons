// Lesson07.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Повторение пройденного материала
/*
1)	Что такое синхронное сообщение?
2)	Что такое асинхронное сообщение?
3)	Каким образом можно отправить синхронное сообщение?
4)	Каким образом можно отправить асинхронное сообщение?
5)	В чём принципиальное отличие функции SendMessage от 
    функции PostMessage?

*/

// Элемент управления «кнопка»
void ex01()
{
	
	/*
	Кнопка - это элемент управления класса BUTTON.

	Типы кнопок:
	https://msdn.microsoft.com/en-us/library/windows/desktop/bb775947%28v=vs.85%29.aspx

	- обычная кнопка (Button)
	- флажок (Check Box)
	- радио кнопка (Radio Button)
	- рамка (Group Boxes)
	- Push Buttons

	Отличаются стилями окон

	Создать кнопку на форме диалога можно двумя способами:

	•	с помощью средств интегрированной среды разработки
	Microsoft Visual Studio;
	•	посредством вызова функции CreateWindow
	*/

	// Обычная кнопка
	/*
		Программный способ создания кнопок с помощью функции CreateWindow
		https://msdn.microsoft.com/en-us/library/windows/desktop/hh298354%28v=vs.85%29.aspx

		Класс окна: BUTTON

		Стили кнопок:

		•	WS_CHILD позволяет создать кнопку как дочернее окно диалога
		•	WS_VISIBLE управляет видимостью кнопки
		•	BS_BITMAP указывает на то, что на кнопке должен быть рисунок
		(растровый битовый образ) вместо текста
		•	Стиль WS_DISABLED указывает на то, что кнопка будет запрещённой

		https://msdn.microsoft.com/en-us/library/windows/desktop/bb775951%28v=vs.85%29.aspx

		Изображение на кнопке можно задать послав сообщение BM_SETIMAGE

		Некоторые сообщения:

		BM_CLICK	имитирует клик по кнопке
		BM_SETSTYLE задает стиль кнопки (или макрос Button_SetStyle)
		BM_GETIMAGE возвращает дескриптор изображения

		https://msdn.microsoft.com/en-us/library/windows/desktop/ff485886%28v=vs.85%29.aspx
		*/
}

// Фокус ввода
void ex02()
{
	// Если кнопка имеет фокус ввода, то текст на кнопке обводится штриховой линией, 
	// а нажатие и отпускание клавиши пробела имеет тот же эффект, что и щелчок 
	// мышью по кнопке

	// Программный способ перевода фокуса ввода на элемент управления:
	/*
	HWND SetFocus(
		HWND hWnd // дескриптор окна, приобретающего клавиатурный ввод
	);
	*/

	//Для получения дескриптора окна (элемента управления), обладающего 
	//фокусом ввода:
	/*
		HWND GetFocus(VOID);
	*/
}

// Флажок (Check Box)
void ex03()
{	
	/*
		Создается со стилями:
			BS_CHECKBOX
			BS_AUTOCHECKBOX
			BS_3STATE
			BS_AUTO3STATE
	*/

	//	Изменение состояния флажка
	/*
		Для того, чтобы перевести Check Box в некоторое состояние,
		ему необходимо отправить сообщение  BM_SETCHECK, передав в
		WPARAM одно из следующих значений:

		•	BST_CHECKED -  установить отметку;
		•	BST_UNCHECKED – снять отметку;
		•	BST_INDETERMINATE - установить неопределенное  состояние.

		Или воспользоваться функцией CheckDlgButton:
		https://msdn.microsoft.com/en-us/library/windows/desktop/ff485884%28v=vs.85%29.aspx

		BOOL CheckDlgButton(
			HWND hDlg, // дескриптор диалога, содержащего кнопку (флажок)
			int nIDButton, // идентификатор элемента управления (флажка)
			UINT uCheck // состояние флажка – одно из вышеперечисленных значений
		);

		Также можно задать состояние макросом:

		LRESULT Button_SetCheck(
			HWND hwndCtl,
			int  check
		);
	*/

	// Получение состояния флажка
	/*
		Для получения состояния флажка следует ему послать сообщение BM_GETCHECK.
		В этом случае SendMessage вернёт одно из вышеперечисленных значений.

		Также можно воспользоваться функцией:

		UINT IsDlgButtonChecked(
			HWND hDlg, // дескриптор диалога, содержащего кнопку (флажок)
			int nIDButton // идентификатор элемента управления (флажка)
		);

		или макросом:

		LRESULT Button_GetCheck(
			HWND hwndCtl
		);

	*/
}

// Переключатель (Radio Button)
void ex04()
{
	/*
		Данный элемент управления обычно применяется для установки или
		сброса определённых опций, независимых друг от друга.

		Флажок действует как двухпозиционный переключатель. Один щелчок
		вызывает  появление контрольной отметки (галочки), а другой щелчок
		приводит к ее исчезновению.

		Создается со стилями:
			BS_RADIOBUTTON
			BS_AUTORADIOBUTTON


		Дополнительные свойства для кнопки-переключателя:

		•	Свойство Auto позволяет элементу управления отслеживать все
		щелчки мышью, и при этом элемент управления сам включает или
		выключает контрольную отметку.
		Если же отключить свойство Auto, то управление флажком
		полностью возлагается на приложение.

		•	Свойство Tri-state используется для создания флажка, имеющего
		три  состояния. Кроме состояний «установлен» и «сброшен»
		добавляется «неопределенное состояние», в котором флажок
		отображен в серой гамме. Серый цвет показывает пользователю,
		что выбор флажка не определен или не имеет отношения к
		текущей операции.

		•	Свойство Push-like изменяет внешний вид флажка так, что он
		выглядит как нажимаемая кнопка. Вместо установки галочки эта
		кнопка переходит в нажатое состояние и остается в нем до
		следующего щелчка мышью.
	*/

	// Изменение состояния радиокнопки
	/*
		Для изменения состояния радиокнопки необходимо отправить сообщение  BM_SETCHECK, 
		передав в WPARAM одно из следующих значений:

			•	BST_CHECKED -  установить отметку;
			•	BST_UNCHECKED – снять отметку;
			•	BST_INDETERMINATE - установить неопределенное  состояние.

		Либо воспользоваться функцией:

		BOOL CheckRadioButton(
			HWND hDlg, // дескриптор диалога, содержащего кнопку (переключатель)
			int nIDFirstButton, // идентификатор первого переключателя в группе
			int nIDLastButton, // идентификатор последнего переключателя в группе
			int nIDCheckButton // идентификатор выбираемого переключателя
		);
		
		При этом функция помечает указанный переключатель в группе, удаляя отметку 
		со всех других переключателей этой же группы.

		Также работает макрос Button_SetCheck
	*/

	// Получение состояния радиокнопки
	/*
		Состояние радиокнопки можно получить такимиже способами, как и для флажка
	*/
}

void ex05()
{
	/*
	Для посылки сообщений непосредственно элементам управления через идентификаторы
	без необходимости получения дескриптора можно использовать функию:

	LRESULT SendDlgItemMessage(
		HWND hDlg,		// дескриптор диалога, содержащего элемент управления
		int nIDDlgItem, // идентификатор дочернего окна (элемента управления),
					    // которому отправляется сообщение
		UINT Msg,		// идентификатор сообщения
		WPARAM wParam,	// дополнительная информация о сообщении
		LPARAM lParam	// дополнительная информация о сообщении
	);
	*/
}

// Практическая часть
/*
Написать игру «Крестики-нолики», учитывая следующие требования:
•	игровое поле размером 3х3 должно состоять из кнопок;
•	при нажатии на кнопку, на ней должна отобразиться картинка (крестик или нолик);
•	необходимо предотвращать попытку поставить крестик или нолик на заня-тую клетку;
•	предоставить пользователю  право выбора первого хода, используя фла-жок;
•	предусмотреть возможность выбора уровня сложности, используя переклю-чатели;
•	предусмотреть кнопку «Начать новую игру».
*/

//Домашнее задание

/*
Написать игру «Пятнашки», учитывая следующие требования :
•	предусмотреть автоматическую перестановку «пятнашек» в начале новой игры;
•	выводить время, за которое пользователь окончил игру(собрал «пятнашки»);
•	предусмотреть возможность начать новую игру.
*/

int main()
{
    return 0;
}

