// SynchronizeThreads.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <Windows.h>

// Повторение пройденного материала
/*
1.	Что такое поток? Какие бывают потоки?
2.	Что такое многопоточность? 
    Чем отличается многопоточность от многозадачности?
3.	В чем заключается актуальность построения многопоточных приложений?
4.	Из  каких компонент состоит поток?
5.	Что такое потоковая функция?
6.	Какая функция API позволяет создать вторичный поток?
7.	Какие существуют способы завершения потока?
8.	Какой способ завершения потока считается наиболее корректным?
9.	Какая функция API позволяет приостановить поток на определенный период 
    времени?
10.	Посредством какой функции API можно «усыпить» поток?
11.	Посредством какой функции API можно возобновить работу потока?
12.	В чем состоит идея вытесняющего планирования на основе приоритетов?
13.	Как определяется суммарный приоритет потока?
14.	Какая функция API предназначена для изменения класса приоритета процесса?
15.	Какая функция API предназначена для получения класса приоритета процесса?
16.	Какая функция API позволяет изменить относительный приоритет потока?
17.	Какая функция API позволяет получить относительный приоритет потока?
18.	Какая функция API используется для получения дескриптора текущего процесса?
19.	Какая функция API используется для получения дескриптора текущего потока?
20.	Какая функция API используется для получения идентификатора текущего процесса?
21.	Какая функция API используется для получения идентификатора текущего потока?
22.	Что такое локальная память потока? Какие существуют виды TLS?
23.	Какие функции библиотеки Tool Help API  позволяют получить информацию о потоках в снимке системы?
*/

// 1.	Проблематика синхронизации потоков
/*
    Все потоки в системе должны иметь доступ к различным системным ресурсам —
    кучам, последовательным портам, файлам, окнам и т.д. Если один из потоков
    запросит монопольный доступ к какому-либо ресурсу, другим потокам, которым
    тоже нужен этот ресурс, не удастся выполнить свои задачи.

    С другой стороны, просто недопустимо, чтобы потоки бесконтрольно
    пользовались ресурсами. Например, если один поток записывает информацию в
    файл, все другие потоки не должны в этот момент времени использовать
    данный файл.

    Таким образом, возникает необходимость синхронизировать работу потоков,
    желающих получить доступ  к одному и тому же ресурсу.
*/

LONG ballance = 100000;

DWORD WINAPI Credit(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
        ballance -= 1;
    }
    return 0;
}

DWORD WINAPI Debet(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
        ballance += 1;
    }
    return 0;
}

void ex01()
{
	HANDLE t[2];
	//Credit(NULL);
	t[0] = CreateThread(NULL, 0, Credit, NULL, NULL, 0);
	//Debet(NULL);
	t[1] = CreateThread(NULL, 0, Debet, NULL, NULL, 0);

	WaitForMultipleObjects(2, t, TRUE, INFINITE);
    _tprintf(TEXT("ballance: %d\n"), ballance);
}

/*
    Другой причиной может быть ожидание одним потоком некоторого события,
    которое может наступить лишь при выполнении другого потока.

    Для таких случаев должны быть предусмотрены специальные средства,
    с помощью которых первый поток будет переведен в состояние ожидания до
    возникновения соответствующего события, а после этого продолжит выполнение.

    Таким образом, следует выделить два основных случая, когда потоки должны
    взаимодействовать друг с другом:
        •	совместное использование разделяемого ресурса (чтобы не разрушить его);
        •	необходимость уведомления других потоков о завершении каких-либо
            операций.

    Cинхронизацию потоков обычно осуществляют с использованием примитивов
    синхронизации, таких как:
        •	атомарные операции API-уровня;
        •	критические секции;
        •	события;
        •	ожидаемые таймеры;
        •	семафоры;
        •	мьютексы.

    На этом и последующих занятиях мы детально ознакомимся
    с каждым из вышеперечисленных примитивов синхронизации.
*/

// 2.	Блокированные вызовы
/*
    Большая часть синхронизации потоков связана с атомарным доступом
    (atomic access) — монопольным захватом ресурса обращающимся к нему потоком.

    Рассмотрим следующий пример:

    LONG g = 0; // определяем глобальную переменную

    DWORD WINAPI Thread1( LPVOID lp )
    {
        ++g;
        return 0;
    }

    DWORD WINAPI Thread2( LPVOID lp )
    {
        ++g;
        return 0;
    }

    Код обеих потоковых функций идентичен: обе функции увеличивают значение
    глобальной переменной g на 1. Поскольку начальное значение переменной g
    равно 0, то, когда оба потока завершат свою работу, значение данной
    переменной станет равным 2.

    Однако в реальности ситуация может быть несколько иной.

    Рассмотрим код потоковых функций, записанный на ассемблере.

    --------------------------------------------------------------------------
    ; поток1
    mov ax, g; в регистр помещается значение переменной g
    inc ax; значение регистра увеличивается на 1
    mov g, ax; в переменную g копируется значение регистра

    ; поток2
    mov ax, g; в регистр помещается значение переменной g
    inc ax; значение регистра увеличивается на 1
    mov g, ax; в переменную g копируется значение регистра
    --------------------------------------------------------------------------

    Однако при параллельной работе потоков вполне допустима следующая
    последовательность выполнения ассемблерного кода.

    --------------------------------------------------------------------------
    MOV EAX, g; выполняется поток 1 - в регистр помещается 0
    INC EAX; выполняется поток 1 - значение регистра увеличивается на 1
    MOV EAX, g; выполняется поток 2 - в регистр помещается 0
    INC EAX; выполняется поток 2 - значение регистра увеличивается на 1
    MOV g, EAX; выполняется поток 1 - значение 1 помещается в переменную g
    MOV g, EAX; выполняется поток 2 - значение 1 помещается в переменную g
    --------------------------------------------------------------------------

    В итоге вместо ожидаемого результата в переменной g окажется 1.

    Для решения данной проблемы необходим механизм, гарантирующий приращение
    значения переменной g на уровне атомарного доступа, т. е. без прерывания
    другими потоками.
*/
/*
    Win32 API предоставляет семейство Interlocked-функций для реализации
    взаимно блокированных операций. При этом все Interlocked-функции работают
    корректно только при условии, что их аргументы выровнены по границе
    двойного слова (DWORD).

    Для увеличения значения переменной на единицу предназначена функция
    API Interlockedlncrement.

    LONG InterlockedIncrement(
        LPLONG lpAddend // адрес переменной, значение которой
                        // инкрементируется
    );

    Для уменьшения значения переменной на единицу предназначена функция
    API InterlockedDecrement.

    LONG InterlockedDecrement(
		LPLONG lpAddend		// адрес переменной, значение которой декрементируется
    );

    Функция API InterlockedExchange монопольно заменяет текущее
    значение переменной типа LONG, адрес которой  передается в первом
    параметре, значением, передаваемым во втором параметре.

    LONG InterlockedExchange(
        PLONG plTarget,// адрес переменной, значение которой заменяется
        LONG lValue // значение для замены
    );

    Функция API InterlockedExchangeAdd добавляет к значению
    переменной, адрес которой  передается в первом параметре,
    значение, передаваемое во втором параметре:

    LONG InterlockedExchangeAdd(
        PLONG plAddend, // адрес переменной, значение которой изменяется
        LONG lIncrement // значение, на которое увеличивается переменная
    );

    Функция API InterlockedCompareExchange выполняет операцию сравнения и
    присваивания по результату сравнения:

    LONG InterlockedCompareExchange(
        LPLONG  plDestination, // адрес переменной, значение которой
                                // изменяется
        LONG lExchange,		   // значение для замены
        LONG lComperand		   // значение для сравнения
    );

    Если значение переменной, адрес которой передается в первом параметре,
    совпадает со значением, передаваемым в третьем параметре, то оно
    заменяется  значением, передаваемым во втором параметре.

*/

// Пример

DWORD WINAPI Credit2(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
        //ballance -= 1;
		InterlockedDecrement(&ballance);		
    }
    return 0;
}

DWORD WINAPI Debet2(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
        //ballance += 1;
		InterlockedIncrement(&ballance);
    }
    return 0;
}

void ex02()
{
    HANDLE t[2];
    t[0] = CreateThread(NULL, 0, Credit2, NULL, NULL, NULL);
    t[1] = CreateThread(NULL, 0, Debet2, NULL, NULL, NULL);

    WaitForMultipleObjects(2, t, TRUE, INFINITE);

    _tprintf(TEXT("ballance: %d"), ballance);
}

// 3.	Критические секции

/*
    Критическая секция (critical section) — это небольшой участок кода,
    требующий монопольного доступа к каким - то общим данным.

    Она позволяет сделать так, чтобы единовременно только один поток
    получал доступ к определенному ресурсу.

    Если в определенный момент времени несколько потоков попытаются
    получить доступ к критической секции, то  контроль над ним будет
    предоставлен только одному из потоков, а все остальные будут
    переведены в состояние ожидания до тех пор, пока участок не
    освободится.

    Для использования критической секции необходимо определить
    переменную типа CRITICAL_SECTION.

    Поскольку эта переменная должна находиться в области видимости
    для  каждого использующего ее потока, обычно ее объявляют глобальной.

    Кроме того, эту  переменную следует инициализировать до ее первого
    применения с помощью  функции API InitializeCriticalSection :

    void InitializeCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection // указатель на объект
                                             // критической
                                             // секции
    );

    Чтобы завладеть критической секцией, поток должен вызвать функцию API
    EnterCriticalSection.


    void EnterCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection // указатель на объект критической
                                             // секции
    );

    Важно отметить, что если критическая секция не используется в данный
    момент другим потоком, то текущий поток захватывает ее и выполняет
    инструкции этой секции, которые следуют сразу после вызова функции
    EnterCriticalSection.

    При этом критическая секция обозначается системой как занятая.

    Если критическая секция в данный момент уже используется другим потоком,
    то текущий поток блокируется до тех пор, пока секция не будет освобождена
    функцией API LeaveCriticalSection.


    void LeaveCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection // указатель на объект критической
                                             // секции
    );

    Следует подчеркнуть, что вызов функции LeaveCriticalSection
    определяет конец критической секции.

    При этом критическая секция обозначается системой как доступная.

    Как только поток получает контроль над критической секцией, доступ
    других потоков к этой секции блокируется.

    При этом очень важно, чтобы время выполнения критической секции было
    минимальным.

    Это позволит добиться наилучших результатов работы приложения.

    Если критическая секция больше не нужна, то используемые ей ресурсы
    необходимо освободить вызовом функции DeleteCriticalSection.

    void DeleteCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection // указатель на объект
                                             // критической
                                             // секции
    );

    Кроме перечисленных выше функций WinAPI предоставляет функцию
    TryEnterCriticalSection, которая позволяет осуществить попытку
    захватить  критическую секцию.

    BOOL TryEnterCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection // указатель на объект
                                             //критической
                                             // секции
    );

    Например:

    CRITICAL_SECTION cs;
    ...
    BOOL bAcquired = TryEnterCriticalSection(&cs);
    if(bAcquired)
    {
        // Выполнение кода критической секции (монопольный
        // доступ к ресурсу)
    }
    else
    {
        // Контроль над критической секцией недоступен
    }

    Как следует из вышеприведенного примера, если критическая секция
    доступна, то поток входит в эту секцию и выполняет ее код, получая
    монопольной доступ к какомуто ресурсу.

    Если секция недоступна, то поток не блокируется, как в случае
    применения функции EnterCriticalSection, а занимается другой работой,
    за что отвечает ветвь else.

*/

CRITICAL_SECTION cs;

DWORD WINAPI Credit3(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
		// установка блокировки
		EnterCriticalSection(&cs);
        ballance -= 1;
		// снятие блокировки
		LeaveCriticalSection(&cs);
    }
    return 0;
}

DWORD WINAPI Debet3(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
		EnterCriticalSection(&cs);
        ballance += 1;
		LeaveCriticalSection(&cs);
    }
    return 0;
}
// Пример
void ex03()
{
    HANDLE t[2];

	InitializeCriticalSection(&cs);

    t[0] = CreateThread(NULL, 0, Credit3, NULL, NULL, NULL);
    t[1] = CreateThread(NULL, 0, Debet3, NULL, NULL, NULL);

    WaitForMultipleObjects(2, t, TRUE, INFINITE);
	
    _tprintf(TEXT("ballance: %d"), ballance);

	DeleteCriticalSection(&cs);
}

/*
    Работая с критическими секциями или применяя Interlocked-функции,
    программа не переключается в режим ядра.

    Поэтому эти виды синхронизации называют синхронизацией в
    пользовательском режиме.

    Она отличается высокой скоростью реализации. Однако главным
    недостатком такой синхронизации является невозможность ее
    применения для потоков, принадлежащих разным процессам.
*/

int main()
{

    //ex01();
    //ex02();
    ex03();
    return 0;
}

