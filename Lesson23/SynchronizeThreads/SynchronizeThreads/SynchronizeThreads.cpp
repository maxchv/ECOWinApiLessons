// SynchronizeThreads.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <Windows.h>

// Повторение пройденного материала
/*
1.	Что такое поток? Какие бывают потоки?
2.	Что такое многопоточность? Чем отличается многопоточность от многозадачности?
3.	В чем заключается актуальность построения многопоточных при-ложений?
4.	Из  каких компонент состоит поток?
5.	Что такое потоковая функция?
6.	Какая функция API позволяет создать вторичный поток?
7.	Какие существуют способы завершения потока?
8.	Какой способ завершения потока считается наиболее коррект-ным?
9.	Какая функция API позволяет приостановить поток на определен-ный период времени?
10.	Посредством какой функции API можно «усыпить» поток?
11.	Посредством какой функции API можно возобновить работу пото-ка?
12.	В чем состоит идея вытесняющего планирования на основе прио-ритетов?
13.	Как определяется суммарный приоритет потока?
14.	Какая функция API предназначена для изменения класса приори-тета процесса?
15.	Какая функция API предназначена для получения класса приори-тета процесса?
16.	Какая функция API позволяет изменить относительный приоритет потока?
17.	Какая функция API позволяет получить относительный приоритет потока?
18.	Какая функция API используется для получения дескриптора те-кущего процесса?
19.	Какая функция API используется для получения дескриптора те-кущего потока?
20.	Какая функция API используется для получения идентификатора текущего процесса?
21.	Какая функция API используется для получения идентификатора текущего потока?
22.	Что такое локальная память потока? Какие существуют виды TLS?
23.	Какие функции библиотеки Tool Help API  позволяют получить информацию о потоках в снимке системы?
*/

// 1.	Проблематика синхронизации потоков
/*
    Все потоки в системе должны иметь доступ к различным системным ресурсам — 
    кучам, последовательным портам, файлам, окнам и т.д. Если один из потоков 
    запросит монопольный доступ к какому-либо ресурсу, другим потокам, которым 
    тоже нужен этот ресурс, не удастся выполнить свои задачи. 
    
    С другой стороны, просто недопустимо, чтобы потоки бесконтрольно 
    пользовались ресурсами. Например, если один поток записывает информацию в 
    файл, все другие потоки не должны в этот момент времени использовать 
    данный файл. 
    
    Таким образом, возникает необходимость синхронизировать работу потоков, 
    желающих получить доступ  к одному и тому же ресурсу.
*/

int ballance = 100000;

DWORD WINAPI Credit(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
        ballance -= 1;
    }
    return 0;
}

DWORD WINAPI Debet(LPVOID arg)
{
    for (int i = 0; i < 100000; i++)
    {
        ballance += 1;
    }
    return 0;
}

void ex01()
{	
    Credit(NULL);
    Debet(NULL);
    _tprintf(TEXT("ballance: %d"), ballance);
}

/*
    Другой причиной может быть ожидание одним потоком некоторого события, 
    которое может наступить лишь при выполнении другого потока. 

    Для таких случаев должны быть предусмотрены специальные средства, 
    с помощью которых первый поток будет переведен в состояние ожидания до 
    возникновения соответствующего события, а после этого продолжит выполнение.

    Таким образом, следует выделить два основных случая, когда потоки должны 
    взаимодействовать друг с другом:
        •	совместное использование разделяемого ресурса (чтобы не разрушить его);
        •	необходимость уведомления других потоков о завершении каких-либо 
            операций.

    Cинхронизацию потоков обычно осуществляют с использованием примитивов 
    синхронизации, таких как:
        •	атомарные операции API-уровня;
        •	критические секции;
        •	события;
        •	ожидаемые таймеры;
        •	семафоры;
        •	мьютексы.
*/



int main()
{

    //ex01();
    
    return 0;
}

