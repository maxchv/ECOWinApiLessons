// Lesson06.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

//Повторение пройденного материала
/*
1)	Что такое диалоговое окно?
2)	Что такое элемент управления?
3)	Какие бывают типы диалоговых окон?
4)	Какая функция позволяет создать модальный диалог и в чём состоит особенность 
    работы этой функции?
5)	Какая функция позволяет создать немодальный диалог?
6)	Какие существуют способы отображения немодального диалогового окна?
7)	В каком случае при создании диалогового приложения функция WinMain должна 
    содержать цикл обработки сообщений?
8)	Какие различия между диалоговой процедурой и оконной процедурой?
9)	Какое сообщение необходимо обработать в диалоговой процедуре, чтобы обеспечить 
    возможность завершения диалога?
10)	Какая функция обеспечивает закрытие модального диалога?
11)	Какие действия необходимо выполнить при обработке сообщения WM_CLOSE 
    для завершения приложения, созданного на основе немодального диалога?
12)	Каким образом в диалоговой процедуре можно запретить вызов стандартного 
    обработчика сообщения?
13)	Какие элементы управления относятся к базовым элементам управления?
14)	Какие элементы управления относятся к общим элементам управления?
15)	Какая функция используется для создания элемента управления?
16)	Какая функция позволяет получить дескриптор элемента управления по его идентификатору?
17)	Какая функция позволяет получить идентификатор элемента управления по его дескриптору?
18)	Каким образом можно сделать элемент управления разрешённым или запрещённым?
19)	Что такое статический элемент управления? 
    Какие бывают типы статических элементов управления?
20)	Какие действия обычно выполняют при обработке сообщения WM_INITDIALOG?
*/

// Синхронные и асинхронные сообщения
void ex01()
{
    // Синхронные сообщения
    /*
    это сообщения, которые Windows помещает в очередь сообщений приложения. 

    В цикле очередное синхронное сообщение выбирается из очереди функцией GetMessage, 
    затем передается Windows посредством функции DispatchMessage, после чего Windows 
    отправляет синхронное сообщение оконной процедуре для последующей обработки.
    */

    // Асинхронные сообщения 
    /*
    передаются непосредственно оконной процедуре для немедленной обработки, 
    минуя очередь сообщений.

    К синхронным сообщениям относятся:
        сообщения о событиях пользовательского ввода
        сообщения от таймера (WM_TIMER)
        сообщение о необходимости перерисовки клиентской области окна (WM_PAINT) 
        сообщение о выходе из программы (WM_QUIT).
     */
    
    //  Асинхронные сообщения являются результатом обработки синхронных  сообщений.
    /*
     Например, когда WinMain вызывает функцию CreateWindow, Windows создает окно и 
     для этого отправляет оконной процедуре асинхронное сообщение WM_CREATE. 
     
     Когда WinMain вызывает ShowWindow, Windows отправляет оконной процедуре 
     асинхронные сообщения WM_SIZE и WM_SHOWWINDOW. 
     
     Когда WinMain вызывает UpdateWindow, Windows отправляет оконной процедуре 
     асинхронное сообщение WM_PAINT.
    */
}

// Посылка сообщений
void ex02()
{
    // SendMessage
    /*
    функция SendMessage посылает асинхронное сообщение указанному окну

    LRESULT SendMessage(
        HWND hWnd, // дескриптор окна, которому отправляется сообщение
        UINT Msg, // идентификатор сообщения
        WPARAM wParam, // дополнительная информация о сообщении
        LPARAM lParam  // дополнительная информация о сообщении
    );

    https://msdn.microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx
    */

    // Функция PostMessage посылает синхронное сообщение указанному окну
    /*
    BOOL PostMessage(
        HWND hWnd, // дескриптор окна, которому отправляется сообщение
        UINT Msg, // идентификатор сообщения
        WPARAM wParam, // дополнительная информация о сообщении
        LPARAM lParam  // дополнительная информация о сообщении
    );

    https://msdn.microsoft.com/en-us/library/windows/desktop/ms644944(v=vs.85).aspx
    */

    /*
    Системные сообщения:
    
    https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx#system_defined

    */

    // Широковещательная рассылка сообщений
    /*
    Если первый параметр вышерассмотренных функций имеет значение 
    HWND_BROADCAST, 
    то  сообщение посылается всем окнам верхнего уровня, 
    существующим в настоящий момент в системе
    */
}

// Практическая часть
void ex03()
{
    /*
        Написать приложение «Слайд-шоу»: на форме диалога расположен статический элемент 
        управления Picture Control, на котором через каждую секунду (или другой временной 
        интервал) меняется изображение. Изображения (Bitmaps – растровые битовые образы) 
        должны храниться в ресурсах приложения. Для использования в программе растрового 
        битового образа, его предварительно следует загрузить функцией API LoadBitmap:

        HBITMAP LoadBitmap(
            HINSTANCE hInstance,  // дескриптор приложения
            LPCTSTR lpBitmapName  // имя растрового битового образа
        );

        https://msdn.microsoft.com/en-us/library/windows/desktop/dd145033(v=vs.85).aspx

        Для установки изображения  на «статик» ему следует отправить сообщение STM_SETIMAGE, 
        передав в WPARAM значение IMAGE_BITMAP, а в LPARAM – дескриптор растрового 
        битового образа.

        SendMessage(hStatic, STM_SETIMAGE, WPARAM(IMAGE_BITMAP), LPARAM(hBmp));

        https://msdn.microsoft.com/en-us/library/windows/desktop/bb760782(v=vs.85).aspx
    */
}

// Домашнее задание
/*
1.	Разработать приложение «убегающий статик». Суть приложения: 
    на форме диалогового окна расположен статический элемент управления. 
    Пользователь пытается подвести курсор мыши к «статику», и, если курсор 
    находится близко со «статиком», элемент управления «убегает». 
    Предусмотреть перемещение «статика» только в пределах диалогового окна.

2.	Разработать диалоговое приложение, позволяющее перетаскивать мышью «статик»,  
    расположенный на форме.
*/

int main()
{
    return 0;
}

