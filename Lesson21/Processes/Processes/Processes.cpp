// Processes.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <Windows.h>
#include <tlhelp32.h>

// 1.	Основные сведения о процессах

// Многозадачность
/*
Многозадачность – это способность операционной системы выполнять 
одновременно несколько программ. При этом каждой программе 
предоставляется квант процессорного времени и создается иллюзия
одновременного выполнения программ. Для многопроцессорных систем 
возможен  истинный параллелизм.
*/

// Процесс
/* 
Процесс – это программа, запущенная на выполнение.
Две запущенные копии одной и той же программы - это два отдельных процесса.

Процесс состоит из двух компонент :
1)	Объект ядра «процесс» – структура данных Windows, через которую 
    система управляет процессом. В ней хранится статистическая информация 
    о процессе.
2)	Адресное пространство, в котором содержится код и данные всех EXE - и 
    DLL модулей.

Процессы инертны. Чтобы процесс что-нибудь выполнил, в нем нужно создать 
поток.

Именно потоки отвечают за исполнение кода, содержащегося в адресном 
пространстве процесса.
*/

// Создание процесса
/*
Для создания процесса используется функция API CreateProcess:

BOOL CreateProcess(
    LPCTSTR lpApplicationName,					// имя приложения
    LPTSTR lpCommandLine,						// имя исполняемого файла	
    LPSECURITY_ATTRIBUTES lpProcessAttributes,	// атрибуты защиты процесса
    LPSECURITY_ATTRIBUTES lpThreadAttributes,	// атрибуты защиты потока
    BOOL bInheritHandles,						// разрешено ли наследование 
    DWORD dwCreationFlags,						// флаг приоритета
    LPVOID lpEnvironment,						// среда окружения
    LPCTSTR lpCurrentDirectory,					// текущий каталог
    LPSTARTUPINFO lpStartupInfo,				// способ отображения главного окна, 
                                                // а также размер и заголовок окна
    LPPROCESS_INFORMATION lpProcessInformation	// информация о порождённом процессе
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx

Когда поток в приложении вызывает функцию CreateProcess, система 
создает объект ядра «процесс» с начальным значением счётчика числа 
его пользователей, равным 1. 

Объект ядра «процесс» — это структура данных, через которую операционная 
система управляет процессом. Затем система создает для нового процесса 
виртуальное адресное пространство и загружает в него код и данные, 
как для исполняемого файла, так и для любых DLL. 

После этого система формирует объект ядра «поток» (со счетчиком, равным 1) 
для первичного потока нового процесса. Как и в первом случае, 
объект ядра «поток» — это структура данных, через которую система 
управляет потоком. Если системе удастся создать новый процесс и его 
первичный поток, CreateProcess вернет TRUE.

Параметры функции CreateProcess:
--------------------------------
================================================================================
    Параметр		|						Описание
================================================================================
lpApplicationName	|	Указатель на строку, содержащую имя исполняемой 
                    |	программы. Имя может быть полное. Если оно не полное, 
                    |	то поиск файла производится в текущем каталоге. 
                    |	Параметру может быть присвоено значение NULL. 
                    |	В этом случае в качестве имени файла выступает 
                    |	первая выделенная пробелами лексема из строки 
                    |	lpCommandLine.
--------------------------------------------------------------------------------
lpCommandLine		|	Указатель командной строки. Если параметр 
                    |	lpApplicationName имеет значение NULL, то имя 
                    |	исполняемого файла выделяется из lpCommandLine, 
                    |	а поиск исполняемого файла производится в следующем 
                    |	порядке:
                    |		1.	Каталог, содержащий ЕХЕ-файл вызывающего 
                    |			процесса.
                    |		2.	Текущий каталог вызывающего процесса.
                    |		3.	Системный каталог Windows.
                    |		4.	Основной каталог Windows.
                    |		5.	Каталоги, перечисленные в переменной 
                    |			окружения PATH.
--------------------------------------------------------------------------------
lpProcessAttributes	|	Указатель на структуру, описывающую параметры защиты 
                    |	процесса. Если параметру присвоено значение NULL, 
                    |	то устанавливаются атрибуты по умолчанию.
--------------------------------------------------------------------------------					|
lpThreadAttributes	|	Указатель на структуру, описывающую параметры защиты 
                    |	первичного потока. Если параметру присвоено 
                    |	значение NULL, то устанавливаются атрибуты по 
                    |	умолчанию.
--------------------------------------------------------------------------------					|
bInheritHandles		|	Параметр определяет, будет ли порожденный процесс 
                    |	наследовать описатели (дескрипторы) объектов ядра 
                    |	родительского процесса.
--------------------------------------------------------------------------------
dwCreationFlags		|	Параметр определяет некоторые дополнительные условия 
                    |	создания процесса и его класс приоритета.
--------------------------------------------------------------------------------
lpEnvironment		|	Указатель на блок переменных среды порожденного 
                    |	процесса. Если этот параметр равен NULL, то 
                    |	порожденный процесс наследует среду родителя.
--------------------------------------------------------------------------------
lpCurrentDirectory	|	Указатель на строку, содержащую полное имя 
                    |	текущего каталога порожденного процесса. 
                    |	Если этот параметр равен NULL, то порожденный 
                    |	процесс наследует каталог родителя.
--------------------------------------------------------------------------------
lpStartupInfo		|	Указатель на структуру STARTUPINFO, которая 
                    |	определяет параметры главного окна порожденного 
                    |	процесса.
--------------------------------------------------------------------------------
lpProcessInformation|	Указатель на структуру PROCESS_INFORMATION, 
                    |	которая будет заполнена информацией о порожденном 
                    |	процессе после возврата из функции.
================================================================================

Cтруктурf STARTUPINFO

typedef struct _STARTUPINFO{
    DWORD cb;			// содержит количество байтов, занимаемых 
                        // структурой STARTUPINFO
    LPTSTR lpReserved;	// зарезервирован
    LPTSTR lpDesktop;	// Идентифицирует имя рабочего стола, на котором 
                        // запускается приложение. Если присвоить NULL, 
                        // процесс связывается с текущим рабочим столом. 
    LPTSTR lpTitle;		// определяет заголовок консольного окна 
    DWORD dwX;			// указывает x - координату окна приложения
    DWORD dwY;			// указывают y - координаты окна приложения
    DWORD dwXSize;		// определяют ширину (в пикселях) окна приложения
    DWORD dwYSize;		// определяют высоту (в пикселях) окна приложения
    DWORD dwXCountChars;// определяют ширину (в символах) консольных окон        
                        // дочернего процесса
    DWORD dwYCountChars;// определяют высоту (в символах) консольных окон       
                        // дочернего процесса
    DWORD dwFillAttribute; // задает цвет текста и фона в консольных окнах      
                        // дочернего процесса
    DWORD dwFlags;		// содержит набор флагов, позволяющих управлять созданием
                        // дочернего процесса.
    WORD wShowWindow;	// Определяет, как именно должно выглядеть первое 
                        // перекрываемое окно дочернего процесса, если приложение 
                        // при первом вызове функции ShowWindow передает в 
                        // параметре nCmdShow идентификатор SW_SHOWDEFAULT. 
    WORD cbReserved2;	// зарезервирован
    LPBYTE lpReserved2; // зарезервирован

    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;	// Последние три поля определяют описатели буферов 
                        // для консольного ввода-вывода. По умолчанию hStdInput 
                        // идентифицирует буфер клавиатуры, a hStdOutput и 
                        // hStdError — буфер консольного окна.
}STARTUPINFO, *LPSTARTUPINFO;
https://msdn.microsoft.com/en-us/library/windows/desktop/ms686331(v=vs.85).aspx

Большинство приложений порождает процессы с атрибутами по умолчанию.  
Но даже в этом случае необходимо инициализировать все элементы структуры 
хотя бы нулевыми значениями, а в элемент cb - заносить размер этой структуры

Структура PROCESS_INFORMATION

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;				// дескриптор созданного процесса
    HANDLE hThread;					// дескриптор первичного потока процесса
    DWORD dwProcessId;				// идентификатор процесса
    DWORD dwThreadId;				// идентификатор первичного потока
}PROCESS_INFORMATION, *LPPROCESS_INFORMATION;
https://msdn.microsoft.com/en-us/library/windows/desktop/ms684873(v=vs.85).aspx
*/

// Способы завершения процесса. 
/* Процесс будет завершён в следующих случаях:

•	входная функция первичного потока возвращает 
    управление (рекомендуемый способ);
•	поток процесса вызывает функцию API ExitProcess;
•	поток другого процесса вызывает функцию API TerminateProcess.

При разработке приложения желательно, чтобы его процесс завершался 
только после возврата управления входной функцией первичного потока.

Это единственный способ, гарантирующий корректную очистку всех ресурсов, 
принадлежавших первичному потоку.

VOID ExitProcess(
    UINT uExitCode		// код завершения процесса
);

BOOL TerminateProcess(
    HANDLE hProcess,	// дескриптор завершаемого процесса
    UINT uExitCode		// код завершения процесса
);

Главное отличие функции TerminateProcess от ExitProcess состоит в том, 
что ее может вызвать любой поток и завершить любой процесс.
*/

// 2.	Основные сведения об объекте ядра
/*
    Объекты ядра используются системой и приложениями для управления  
    самыми разнообразными ресурсами, например, процессами, потоками, 
    файлами, семафорами, событиями и многими другими. 
    
    Каждый объект ядра — это блок памяти, выделенный ядром и доступный 
    только ему. 
    
    Этот блок представляет собой структуру данных, в полях которой 
    содержится информация об объекте. 
    
    Некоторые поля (дескриптор защиты, счетчик числа пользователей и др.) 
    присутствуют во всех объектах, но большая их часть специфична для 
    объектов ядра конкретного типа. 
    
    Например, у объекта ядра «процесс» есть идентификатор, базовый приоритет 
    и код завершения, а у объекта ядра «файл» — смещение в байтах, 
    режим разделения и режим открытия.

    -------------------------------------------------------------------------

    Структуры объектов ядра доступны только ядру, и приложение не может 
    самостоятельно найти эти структуры в памяти и напрямую модифицировать их 
    содержимое. 
    
    Такое ограничение введено намеренно, чтобы ни одна программа не могла  
    нарушить целостность структур объектов ядра. 
    
    При этом в Windows предусмотрен набор функций, обрабатывающих структуры 
    объектов ядра по строго определенным правилам. 
    
    Таким образом, программа может получить доступ к объектам ядра только 
    через эти функции.

    --------------------------------------------------------------------------

    Объекты ядра принадлежат ядру, а не процессу. То есть, если некоторый процесс 
    вызывает функцию, создающую объект ядра, а затем завершается, объект ядра 
    может быть не разрушен, в случае если созданный объект ядра используется 
    другим процессом. Ядро запретит разрушение объекта до тех пор, пока от него 
    не откажется и тот процесс

    ---------------------------------------------------------------------------

    Ядру всегда известно, сколько процессов использует конкретный объект ядра, 
    поскольку в каждом объекте есть счетчик числа его пользователей. В момент 
    создания объекта счетчику присваивается единичное значение. 
    
    Когда к существующему объекту ядра обращается другой процесс, счетчик 
    увеличивается на 1. А когда какой-то процесс завершается, счетчики всех 
    используемых им объектов ядра автоматически уменьшаются на 1. Как только
    счетчик какого-либо объекта обнуляется, ядро уничтожает этот объект.

    Объекты ядра можно защитить специальным дескриптором защиты, который описывает,
    кто создал объект и кто имеет права на доступ к нему. Дескрипторы защиты 
    обычно используется при написании серверных приложений. При разработке 
    клиентского приложения объект ядра чаще всего создаётся с защитой по умолчанию.

    ---------------------------------------------------------------------------

    Любая функция, создающая объект ядра (например, CreateFile), возвращает 
    дескриптор созданного объекта. Для большей надежности  операционной системы 
    Microsoft значения дескрипторов объектов ядра действительны только 
    в адресном пространстве процесса, их создавшего.  
    
    Поэтому все попытки передачи такого дескриптора другому процессу с помощью
    какого-либо механизма межпроцессной связи и его использования в другом 
    процессе приводят к ошибкам. 
    
    Это обусловлено тем, что для каждого процесса создаётся таблица дескрипторов,
    в которой каждая строка идентифицирует объект ядра, используемый данным 
    процессом.

    ==============================================================================
       Индекс			Указатель на блок памяти	Маска доступа		Флаги
    (дескриптор)			(объект ядра)				(DWORD)			(DWORD)
    ==============================================================================
        1						0x???					  0x???			  0x???
        2						0x???					  0x???			  0x???
        3						0x???					  0x???			  0x???
    ==============================================================================

    Указатель на блок памяти (объект ядра) – содержит адрес системной памяти, 
    где расположен объект ядра.
    
    Маска доступа (DWORD) – определяет, кто имеет доступ к объекту. 
    Если маска доступа не указывается при создании объекта, то доступ к нему 
    имеют только члены группы администраторов.
    
    Флаги (DWORD) – опции для созданного объекта. Например, наследуется ли 
    дескриптор или нет.

    Таким образом, любая функция, возвращающая дескриптор объекта ядра, 
    вписывает новую строку в таблицу дескрипторов. Дескриптор служит в качестве 
    индекса, соответствующего строке таблицы. 
    
    При вызове функции, принимающей в качестве аргумента дескриптор объекта ядра,
    происходит обращение в таблицу дескрипторов, принадлежащих конкретному 
    процессу, и считывается адрес нужного объекта ядра. 
    
    Если же передать функции дескриптор, относящийся к «чужому» процессу 
    (т.е. индекс, которого нет в таблице), функция завершится с ошибкой и 
    функция GetLastError возвратит значение  ERROR_INVALID_HANDLE.

    -------------------------------------------------------------------------

    При вызове функции API CloseHandle происходит уничтожение строки из таблицы
    дескрипторов.

    BOOL CloseHandle(
        HANDLE hObject //дескриптор объекта ядра
    );

    Эта функция сначала проверяет таблицу дескрипторов данного процесса, 
    чтобы убедиться, что процесс имеет доступ к объекту hObject. 
    Если доступ разрешен, то система получает адрес структуры данных объекта
    hObject и уменьшает в ней счетчик количества пользователей. 
    
    Как только счетчик обнулится, ядро удаляет объект из памяти.
*/

// 3.	Дочерние процессы
// 3.1.	Понятие дочернего процесса
/*
    При разработке приложения часто бывает нужно, чтобы какую-то операцию 
    выполнял другой блок кода. Поэтому приходится вызывать функции или 
    подпрограммы. 
    
    Но вызов функции приводит к приостановке выполнения основного кода программы 
    до возврата из вызванной функции. Один из альтернативных способов состоит в том,
    что процесс порождает дочерний при помощи уже рассмотренной функции 
    CreateProcess и возлагает на него выполнение части операций.
*/

// 3.2.	Наследование дескрипторов объектов ядра
/*
    Время от времени возникает необходимость в разделении объектов ядра между 
    потоками, исполняемыми в разных процессах. Причин тому может быть несколько:
        •	объекты «проекции файлов» позволяют двум процессам, исполняемым 
            на одной машине, совместно использовать одни и те же блоки данных;
        •	почтовые ящики и именованные каналы дают возможность программам 
            обмениваться данными с процессами, исполняемыми на других машинах 
            в сети;
        •	мьютексы, семафоры и события позволяют синхронизировать потоки, 
            исполняемые в разных процессах, чтобы одно приложение могло уведомить 
            другое об окончании той или иной операции.
    
    Как отмечалось ранее, значения дескрипторов объектов ядра действительны только 
    в адресном пространстве процесса, их создавшего. Однако существуют механизмы, 
    позволяющие процессам совместно использовать одни и те же объекты ядра. 
    
    Один из таких механизмов заключается в наследовании описателя (дескриптора) 
    объекта ядра в дочернем процессе. Другими словами, родительский процесс может 
    передавать по наследству дочернему процессу дескрипторы объектов ядра. 	
    Дескрипторы при этом должны быть наследуемыми, что можно явно указать при 
    их создании.

    Объект ядра «файл» можно создать при помощи функции:

    HANDLE CreateFile(
        LPCTSTR lpFileName,				// имя создаваемого или открываемого файла
        DWORD dwDesiredAccess,			// способ доступа к содержимому файла
        DWORD dwShareMode,				// тип совместного доступа к данному файлу
        LPSECURITY_ATTRIBUTES 
                lpSecurityAttributes,	// атрибуты защиты
        DWORD dwCreationDisposition,	// действие, которое необходимо выполнить 
                                        // в том случае, если файл существует, и в 
                                        // том случае, если файл не существует 
        DWORD dwFlagsAndAttributes,		//атрибуты файла
        HANDLE hTemplateFile			// дескриптор с правами доступа GENERIC_READ
                                        // к шаблону файла, который предоставляет 
                                        // расширенные атрибуты для создаваемого 
                                        файла 
    );
    https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx

    Параметр lpSecurityAttributes функции CreateFile, представляет наибольший 
    интерес. Этот параметр – указатель на структуру SECURITY_ATTRIBUTES, 
    определяющую атрибуты безопасности, с которыми создаётся объект ядра.

    Структура SECURITY_ATTRIBUTES:

    typedef struct _SECURITY_ATTRIBUTES {
        DWORD nLength,					// размер структуры в байтах
        LPVOID lpSecurityDescriptor;	// дескриптор безопасности
        BOOL bInheritHandle;			// данный параметр указывает, будет ли 
                                        // дескриптор    объекта ядра наследуемым 
    } SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES;
    https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560(v=vs.85).aspx

    Для того чтобы дочерний процесс мог наследовать дескрипторы  объектов ядра 
    родительского процесса необходимо в 5-м параметре bInheritHandles функции 
    CreateProcess указать TRUE. При инициализации дочернего процесса система
    сформирует в нем пустую таблицу описателей объектов ядра. Затем в эту таблицу 
    из таблицы родительского процесса  будут скопированы записи, соответствующие 
    объектам ядра, у которых наследуемые дескрипторы. Причем копирование произойдёт
    в те же позиции. 
    
    Последний факт чрезвычайно важен, так как означает, что дескрипторы будут 
    идентичны в обоих процессах (родительском и дочернем). Помимо копирования 
    записей из таблицы описателей, система увеличивает значения счетчиков 
    соответствующих объектов ядра, поскольку эти объекты теперь используются 
    обоими процессами. Чтобы уничтожить какойто объект ядра, его описатель должны 
    закрыть (вызовом CloseHandle) оба процесса. 
    
    Cразу после возврата управления функцией CreateProcess родительский 
    процесс может закрыть свой описатель объекта, и это никак не отразится на 
    способности дочернего процесса манипулировать  этим объектом.

    -----------------------------------------------------------------------------

    Дочерний процесс не знает о том, что он унаследовал какие-то дескрипторы.
    Поэтому наследование дескрипторов объектов ядра полезно только когда дочерний 
    процесс сообщает, что при его создании родительским процессом он ожидает 
    доступа к какому-нибудь объекту ядра. 
    
    Для этого в дочерний процесс обычно передают значение ожидаемого им 
    дескриптора объекта ядра как аргумент в командной строке. 
    
    Инициализирующий код дочернего процесса анализирует командную строку, 
    извлекает из нее значение дескриптора, и дочерний процесс получает 
    неограниченный доступ к объекту.  
    
    При этом механизм наследования срабатывает только потому, что значение 
    дескриптора разделяемого объекта ядра в родительском и дочернем процессах 
    одинаково.
*/

// 3.3.Запуск обособленных дочерних процессов

/*
Чаще всего приложение создает другие процессы как обособленные.
Это означает, что после создания и запуска нового процесса родительскому
процессу нет нужды с ним взаимодействовать или ждать, пока тот закончит 
работу.

Чтобы создать обособленный дочерний процесс необходимо вызовом CloseHandle 
закрыть свои описатели, связанные с новым процессом и его первичным потоком.

Приведенный ниже фрагмент кода демонстрирует вышесказанное.

STARTUPINFO s = { sizeof(STARTUPINFO) };
PROCESS_INFORMATION p;
TCHAR buffer[] = TEXT("Calc.exe");
BOOL fs = CreateProcess(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &s, &p);
if (fs)
{
    CloseHandle(p.hThread);
    CloseHandle(p.hProcess);
}
*/

void ex()
{
	STARTUPINFO s = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION p;
	TCHAR buffer[] = TEXT("Calc.exe");
	BOOL fs = CreateProcess(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &s, &p);
	if (fs)
	{
		CloseHandle(p.hThread);
		CloseHandle(p.hProcess);
	}
}

// Демонстрация приложения
void ex00()
{
	SECURITY_ATTRIBUTES sa = { 0 };
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	HANDLE h = CreateFile(TEXT("Test.txt"),
		GENERIC_READ,
		0,
		&sa,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (h == INVALID_HANDLE_VALUE)
	{
		_tprintf(TEXT("ERROR"));
		return;
	}
	TCHAR buff[100] = { '\0' };
	DWORD count = 0;
	ReadFile(h, buff, sizeof(buff), &count, NULL);
	MessageBox(NULL, buff, TEXT(""), MB_OK);
	CloseHandle(h);
}

// 4. Получение списка запущенных в системе процессов

/*
Cнимок системы необходим для того, чтобы получить информацию обо всех 
запущенных в системе процессах, их потоках, используемой процессами 
памяти и т.д.

Для получения снимка системы необходимо воспользоваться функцией 
CreateToolhelp32Snapshot.

HANDLE WINAPI CreateToolhelp32Snapshot(
    DWORD dwFlags,		// набор флагов, определяющих, какие параметры будут
                        // записаны в снимок системы
    DWORD th32ProcessID // идентификатор процесса, о котором необходимо 
                        // получить информацию. 
                        // Если данный параметр равен 0, то запрашивается
                        // информация о текущем процессе. Этот параметр 
                        // имеет смысл, когда необходимо получить список 
                        // куч и модулей, используемых конкретным 	
                        // процессом, в противном случае параметр 
                        // игнорируется
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx

Первый параметр данной функции может принимать следующие значения:

TH32CS_INHERIT		Снимок может наследоваться дочерними процессами
TH32CS_SNAPALL		Комбинация флагов TH32CS_SNAPHEAPLIST, 
                    TH32CS_SNAPMODULE, TH32CS_SNAPPROCESS 
                    и TH32CS_SNAPTHREAD
TH32CS_SNAPHEAPLIST	В снимок включается список куч, принадлежащих процессу
TH32CS_SNAPMODULE	В снимок  включается  список  модулей, принадлежащих  
                    процессу
TH32CS_SNAPPROCESS	В  снимок  включается  список процессов, запущенных 
                    в системе
TH32CS_SNAPTHREAD	В снимок включается список потоков

--------------------------------------------------------------------------

Для получения списка запущенных процессов из снимка системы следует 
воспользоваться функциями Process32First и Process32Next.

При этом сначала необходимо вызвать функцию Process32First для получения 
информации о первом процессе в списке.

BOOL WINAPI Process32First(
    HANDLE hSnapshot,		// дескриптор снимка системы
    LPPROCESSENTRY32 lppe	// указатель на структуру PROCESSENTRY32, 
                            // которая 	будет заполнена информацией о 
                            // первом процессе в снимке
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx

Чтобы получить информацию об остальных процессах в снимке си-стемы необходимо многократно вызывать функцию Process32Next.

BOOL WINAPI Process32Next(
    HANDLE hSnapshot,	  // дескриптор снимка системы
    LPPROCESSENTRY32 lppe // указатель на структуру PROCESSENTRY32, 
                          // которая будет заполнена информацией о 
                          // следующем процессе в снимке
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836(v=vs.85).aspx

Структура PROCESSENTRY32:

typedef struct tagPROCESSENTRY32
{
    DWORD dwSize;					// размер структуры в байтах
    DWORD cntUsage;					// не используется и должен быть 0
    DWORD th32ProcessID;			// идентификатор процесса
    ULONG_PTR th32DefaultHeapID;	// не используется и должен быть 0
    DWORD th32ModuleID;				// не используется и должен быть 0
    DWORD cntThreads;				// количество потоков в процессе
    DWORD th32ParentProcessID;		// идентификатор родительского процесса
    LONG pcPriClassBase;			// базовый приоритет всех потоков, созданных в 						\
                                    // процессе
    DWORD dwFlags;					// не используется и должен быть 0
    TCHAR szExeFile[MAX_PATH];		// название ехе-файла для данного процесса
} PROCESSENTRY32, *PPROCESSENTRY32;
https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839(v=vs.85).aspx


Для получения описателя процесса по его идентификатору используется функция OpenProcess

HANDLE OpenProcess(
    DWORD dwDesiredAccess,  // желаемый уровень доступа (PROCESS_ALL_ACCESS –  	
                            // полный доступ)
    BOOL bInheritHandle,	// если значение параметра равно TRUE, тогда
                            // полученный дескриптор можно передавать между процессами, в противном     	// случае дескриптор ненаследуемый
    DWORD dwProcessId		// идентификатор процесса
);

*/

// Пример перечисления запущенных процессов
void ex01()
{	
    HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (h == INVALID_HANDLE_VALUE)
    {
        _tprintf(TEXT("Error!"));
        return;
    }

    PROCESSENTRY32 process;
    process.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(h, &process))
    {  
		int i = 1;
        do
        {			
            _tprintf(TEXT("\n\n====================================================="));
            _tprintf(TEXT("\n%d) PROCESS NAME:  %s"), i, process.szExeFile);
            _tprintf(TEXT("\n-------------------------------------------------------"));
            _tprintf(TEXT("\n  Process ID        = 0x%08X"), process.th32ProcessID);
            _tprintf(TEXT("\n  Thread count      = %d"), process.cntThreads);
            _tprintf(TEXT("\n  Parent process ID = 0x%08X"), process.th32ParentProcessID);
            if (!lstrcmp(process.szExeFile, TEXT("calc.exe")))
            {
                HANDLE hPR = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process.th32ProcessID);
                TerminateProcess(hPR, 0); // завершить процесс
            }
			i++;
		} while (Process32Next(h, &process));
    }
}


int _tmain(int argc, _TCHAR* argv[])
{
	//ex();
	//ex00();
    ex01();
	
    return 0;
}

