// 01.SynchronizeThreads2.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Повторение пройденного материала
/*
1.	В каких случаях возникает необходимость синхронизации потоков?
2.	Какие существуют примитивы синхронизации?
3.	Что такое атомарный доступ?
4.	Какие преимущества имеют Interlocked-функции перед операторами C++? 
    В каких случаях желательно их применять?
5.	Что такое критическая секция?
6.	Какая функция служит для инициализации объекта критической секции?
7.	Какая функция позволяет потоку завладеть критической секцией?
8.	Посредством какой функции поток освобождает критическую секцию?
9.	Какая функция позволяет освободить ресурсы, используемые критической 
    секцией?
10.	Каким преимуществом обладает критическая секция?
11.	Какой недостаток у синхронизации в пользовательском режиме?
*/

// 1.	Мьютексы 
/*
Мьютекс(mutual exclusion – mutex) – это объект ядра, который гарантируют
потокам взаимоисключающий доступ к единственному ресурсу.

Мьютекс содержит следующие поля:
    •	счетчик числа пользователей;
    •	счетчик рекурсии;
    •	идентификатор потока-владельца.

Ммьютексы очень похожи на критические секции. Однако если критические 
секции являются объектами пользовательского режима, то мьютексы — это 
объекты ядра.

Поэтому они позволяют синхронизировать доступ к ресурсу нескольких 
потоков из разных процессов.

Идентификатор потока - владельца определяет, какой поток захватил мьютекс,
а счетчик рекурсий показывает, сколько раз это произошло.

Следует подчеркнуть, что мьютексы – это объекты ядра, наиболее часто 
используемые для синхронизации потоков.

Как правило, с их помощью защищают блок памяти, к которому обращается
множество потоков.

Если бы потоки одновременно использовали какой - то блок памяти, то 
данные в нем были бы повреждены.

Мьютексы гарантируют, что любой поток получает монопольный доступ к 
блоку памяти, и тем самым обеспечивают целостность данных.

Для использования объекта - мьютекса один из потоков должен сначала  
создать его вызовом функции API CreateMutex.

HANDLE  CreateMutex (
    LPSECURITY_ATTRIBUTES lpMutexAttributes, // атрибуты доступа 
    BOOL bInitialOwner,						 // флаг наличия потока-владельца 
    LPCTSTR pszName							 // имя объекта 
    );

https://msdn.microsoft.com/en-us/library/windows/desktop/ms682411(v=vs.85).aspx

Параметр blnitialOwner определяет начальное состояние мьютекса. Если 
он имеет значение FALSE, то объект-мьютекс не принадлежит ни одному из 
потоков и поэтому находится в свободном состоянии. 
При этом его идентификатор  потока-владельца и счетчик рекурсии равны 
нулю. 

Если же в этом параметре  передается значение TRUE, то идентификатор 
потока-владельца в мьютексе приравнивается идентификатору вызывающего
потока, а счетчик рекурсии получает  единичное значение. Если 
идентификатор потока-владельца не равен нулю, мьютекс 
считается занятым.

Всякий раз, когда поток захватывает объект-мьютекс, счетчик рекурсии 
в этом объекте увеличивается на 1. 

Единственная ситуация, в которой значение счетчика рекурсии может быть 
больше 1, - поток захватывает один и тот же мьютекс несколько раз.

Любой поток может получить дескриптор существующего объекта-мьютекса, вызвав функцию API OpenMutex.

HANDLE OpenMutex(
    DWORD dwDesiredAccess,// права доступа (MUTEX_ALL_ACCESS – полный доступ)
    BOOL blnheritHandle,  // параметр определяет, будет ли наследоваться 	
                          // дескриптор мьютекса (если TRUE – дескриптор 
                          // наследуемый)
    LPCTSTR pszName		  // имя мьютекса
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms684315(v=vs.85).aspx

Для получения доступа к разделяемому ресурсу поток обычно вызывает 
функцию WaitForSingleObject и передает ей дескриптор мьютекса, 
охраняющего этот ресурс.

DWORD WaitForSingleObject(
    HANDLE hHandle,		   // дескриптор объекта ядра «мьютекс»
    DWORD dwMilliseconds   // время ожидания
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx

Когда некоторый поток вызывает функцию WaitForSingleObject, параметр 
hHandle идентифицирует объект ядра «мьютекс», который может находится 
либо в свободном, либо в занятом состоянии. 

Параметр dwMilliseconds задает таймаут — временной интервал, спустя 
который функция  возвращает управление, даже если объект остается в 
занятом состоянии. Если параметр dwMilliseconds имеет нулевое значение, 
то функция только проверяет состояние объекта и возвращает управление 
немедленно. Константа INFINITE в качестве  значения dwMilliseconds задает 
бесконечное значение таймаута.

Возвращаемым значением функции WaitForSingleObject чаще всего является 
одна из следующих констант:

WAIT_OBJECT_0	Контролируемый объект ядра перешел в свободное 
                (сигнальное) состояние, т.е. произошел захват мьютекса
WAIT_TIMEOUT	Истек  интервал  тайм-аута, а  контролируемый объект 
                ядра остался в занятом (несигнальном) состоянии
WAIT_FAILED		Функция завершилась с ошибкой.
WAIT_ABANDONED	Объект мьютекса не был освобожден тем потоком, который 
                им владел, по причине того, что поток был некорректно 
                завершен. В этом случае мьютекс переводится в сигнальное
                состояние и им овладевает тот поток, который его ожидал.

Функция WaitForSingleObject проверяет у мьютекса идентификатор 
потока-владельца. 

Если идентификатор равен нулю, то ресурс свободен и вызывающий поток 
может продолжить выполнение. 

В этом случае перед возвратом из функции идентификатор  потока-владельца 
в мьютексе становится равным идентификатору вызывающего потока, 
а счетчику рекурсии присваивается единичное значение.

Если функция WaitForSingleObject определяет, что идентификатор 
потока-владельца не равен нулю, то вызывающий поток переходит в состояние
ожидания до тех пор, пока мьютекс не перейдет в сигнальное состояние,
т.е. пока захваченный мьютекс не будет освобожден.


Когда поток, занимающий ресурс, заканчивает с ним работать, он должен 
освободить мьютекс вызовом функции API ReleaseMutex.

BOOL ReleaseMutex(
    HANDLE hMutex // дескриптор мьютекса
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms685066(v=vs.85).aspx

Функция ReleaseMutex уменьшает значение счетчика рекурсии в мьютексе на 
единицу. Если счетчик рекурсии становится равным нулю, то обнуляется 
также идентификатор потока-владельца.

ВАЖНО!!! все проверки и изменения  состояния объекта-мьютекса выполняются
на уровне АТОМАРНОГО доступа.

Система допускает рекурсивный многократный захват мьютекса одним потоком.
В этом случае счетчик рекурсии в мьютексе каждый раз увеличивается на 
единицу. 

Важно отметить, что в этой ситуации для освобождения мьютекса количество 
вызовов потоком функции ReleaseMutex должно совпадать с количеством 
предыдущих захватов мьютекса
*/

///////////////////////
//// Пример приложений 
///////////////////////

// 2.	Семафоры
/*
Семафор – это объект синхронизации, который предоставляет доступ к 
разделяемому ресурсу ограниченному количеству потоков.

Семафор содержит:
	•	счетчик числа пользователей;
	•	максимальное количество ресурсов, контролируемых семафором;
	•	счетчик текущего числа ресурсов.

Объект ядра «семафор» создается вызовом функции API CreateSemaphore.

HANDLE CreateSemaphore(
	PSECURITY_ATTRIBUTE psa,	// атрибуты безопасности
	LONG lInitialCount,			// текущее количество доступных ресурсов
	LONG lMaximumCount,			// максимальное количество ресурсов
	PCSTR pszName				// имя семафора
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms682438(v=vs.85).aspx

Синхронизация работы потоков с использованием семафоров состоит в 
следующем. 
Предположим, что необходимо предоставить доступ к какому-то ресурсу трем
потокам. Сначала объект ядра «семафор» инициализируется и ему передается 
количество потоков (в нашем случае 3), которые к нему могут обратиться. 
Далее при каждом обращении к семафору его счетчик ресурсов уменьшается. 
И когда счетчик уменьшиться до 0, то к семафору нельзя будет больше 
обратиться. 

При отсоединении потоков от семафора его счетчик ресурсов увеличивается, 
что позволяет другим потокам обращаться к нему.

Сигнальному состоянию семафора соответствует значение счетчика ресурсов, 
большее нуля. 

Когда счетчик равен нулю, семафор считается не установленным (сброшенным).

Любой поток может получить дескриптор существующего объекта-семафора,
вызвав функцию API OpenSemaphore.

HANDLE OpenSemaphore(
	DWORD dwDesiredAccess,	// права доступа
							// (SEMAPHORE_ALL_ACCESS – полный доступ)
	BOOL blnheritHandle,	// параметр определяет, будет ли наследоваться 
							// дескриптор семафора (если TRUE – дескриптор 
							// наследуемый)
	LPCTSTR pszName			// имя семафора
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms684326(v=vs.85).aspx

Поток может увеличить значение счетчика текущего числа доступных ресурсов 
на величину lReleaseCount, вызывая функцию API ReleaseSemaphore.

BOOL ReleaseSemaphore(
	HANDLE hSemaphore,		// дескриптор семафора
	LONG lReleaseCount,		// приращение количества доступных ресурсов
	LPLONG lpPreviousCount	// предыдущее значение счетчика ресурсов
);
https://msdn.microsoft.com/en-us/library/windows/desktop/ms685071(v=vs.85).aspx

Для получения доступа к разделяемому ресурсу поток вызывает функцию 
WaitForSingleObject и передает ей дескриптор семафора, охраняющего этот 
ресурс. 

Функция WaitForSingleObject проверяет у семафора значение счетчика 
текущего числа ресурсов. Если оно больше нуля и семафор свободен, 
то значение счетчика уменьшается на единицу, а  вызывающий поток 
продолжает выполнение. 

При этом важно, что эта операция выполняется для семафора на уровне 
атомарного доступа. Иначе говоря, пока wait-функция не вернет управление,
операционная система не позволит прервать эту операцию  никакому другому
потоку.

Если wait-функция определяет, что счетчик текущего числа ресурсов равен 
нулю (семафор занят), то система переводит вызывающий поток в состояние
ожидания до тех пор, пока другой поток не увеличит значение этого счетчика.
*/

///////////////////////
//// Пример приложений 
///////////////////////

int main()
{
    return 0;
}

