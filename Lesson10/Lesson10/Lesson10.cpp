// Lesson10.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Повторение пройденного материала
/*
1)	Чем отличается обычный список от комбинированного списка?
2)	Какими способами можно создать список на диалоге?
3)	Какое сообщение придёт в диалоговую процедуру при выборе элемента списка?
4)	Какое уведомление от списка приходит родительскому окну (диалогу) при 
    изменении текущего выбора?
5)	Какие сообщения необходимо отправить списку для добавления, вставки 
    и удаления строки?
6)	Какое сообщение необходимо отправить списку для поиска в нём указанной строки?
7)	Какое сообщение необходимо отправить списку, чтобы определить индекс 
    выбранного элемента списка?
8)	Как программно выбрать элемент списка?
9)	Какое сообщение необходимо отправить списку, чтобы определить 
    количество элементов в нем?
10)	Какое сообщение необходимо отправить списку, чтобы его очистить?
11)	Какое сообщение необходимо отправить списку, чтобы получить текст 
    указанного элемента?
12)	Какая функция возвращает битовую маску логических дисков, 
    которые доступны в данный момент?
13)	Какая функция возвращает тип накопителя по заданному имени 
    корневого пути?
*/

// Распаковщики сообщений

// Общие элементы управления.

// Элемент управления «индикатор процесса»(Progress Control).

// Сообщения индикатора процесса.

// Практическая часть.
/*
	Распаковщики сообщений (Message crackers) упрощают написание 
	оконной процедуры, в теле которой обычно один огромный 
	оператор switch, содержащий большое число строк кода, что 
	является образцом плохого стиля программирования. 
	
	Распаковщики сообщений позволяют разбить оператор switch на 
	небольшие функции – по одной на оконное сообщение. 
	Это значительно улучшает внутреннюю структуру кода.

	Макрос (windowsx.h)

	#define	HANDLE_MSG(hwnd, message, fn)   
		case (message): 
			return HANDLE_##message((hwnd), (wParam), 
			                         (lParam), (fn))
*/
/*
	Для обработки сообщения WM_CLOSE необходимо в операторе 
	switch оконной процедуры указать макрос HANDLE_MSG

	BOOL CALLBACK DlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
		switch(message)
		{
			HANDLE_MSG(hwnd, WM_CLOSE, Cls_OnClose);
		}
		return FALSE;
	}

	В коде приложения предусмотреть функцию–обработчик 
	сообщения WM_CLOSE:

	void Cls_OnClose(HWND hwnd)
	{
		EndDialog(hwnd, 0);
	}
*/

/*
	Макросы HANDLE_##message (например, HANDLE_WM_CLOSE, 
	HANDLE_WM_COMMAND и т.д.) представляют собой распаковщики 
	сообщений. Они распаковывают содержимое параметров 
	wParam и lParam, выполняют нужные преобразования типов и 
	вызывают соответствующую функцию – обработчик сообщения 
	(например, Cls_OnClose). 
	
	Например, макрос HANDLE_WM_CLOSE определён следующим образом:

	#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) 
									((fn)(hwnd), 0L)

	Макросы FORWARD_WM_* - это предописатели сообщений 
	(message forwarder), которые используется в том случае, 
	когда  при обработке сообщения необходимо вызвать 
	стандартный обработчик по умолчанию.

	// обработка по умолчанию
	FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, DefWindowProc);
*/

/*
Преимущества распаковщиков сообщений:
•	сокращение числа явных преобразований типов в 
	коде приложения, а также возникающих при этом ошибок;
•	читабельность кода;
•	простота и удобство в использовании при разработке 
	приложения.
*/

// Общие элементы управления.
/*
	Общие элементы управления, включенные в библиотеку 
	элементов управления общего пользования 
	(common control library),  дополняют базовые элементы 
	управления  и  позволяют придать приложениям более 
	совершенный вид. 
	
	К общим элементам управления относятся 
		- панель инструментов (Toolbar)
		- окно подсказки (Tooltip)
		- индикатор (Progress Bar)
		- счётчик (Spin Control)
		- строка состояния (Status Bar) и другие. 
	
	Библиотека элементов управления общего пользования 
	реализована в виде динамически загружаемой 
	библиотеки comctl32.dll.
*/

/*
	Разница между базовыми элементами управления и общими 
	элементами управления состоит в типе посылаемых 
	уведомительных сообщений. 
	
	Базовые элементы управления посылают сообщения 
	WM_COMMAND, а общие элементы  управления  почти всегда 
	посылают сообщения WM_NOTIFY.
*/
/*
	Чтобы использовать в приложении какой-либо элемент 
	управления общего пользования, сначала нужно вызвать 
	функцию API InitCommonControlsEx, которая регистрирует 
	оконные классы элементов управления.

	BOOL InitCommonControlsEx(
		LPINITCOMMONCONTROLSEX lpInitCtrls
	);
	https://msdn.microsoft.com/en-us/library/windows/desktop/bb775697%28v=vs.85%29.aspx

	Структура INITCOMMONCONTROLSEX имеет следующее определение:

	typedef struct tagINITCOMMONCONTROLSEX {
		DWORD dwSize; // размер структуры в байтах
		DWORD dwICC; // флаги загрузки классов из DLL
	} INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;


	Второй параметр может принимать одно или несколько значений:
	ICC_ANIMATE_CLASS			animate
	ICC_BAR_CLASSES				toolbar, status bar, 
								slider, tooltip
	ICC_LISTVIEW_CLASSES		list view, header
	ICC_PROGRESS_CLASS			progress bar
	ICC_TAB_CLASSES				tab, tooltip
	ICC_TREEVIEW_CLASSES		tree view, tooltip
	ICC_UPDOWN_CLASS			up-down
	ICC_WIN95_CLASSES			animate, header, hot key, 
								list view, progress bar, 
								status bar, tab, tooltip, 
								toolbar, slider, tree view, 
								up-down
	https://msdn.microsoft.com/en-us/library/windows/desktop/bb775507%28v=vs.85%29.aspx
		
	Для  того  чтобы  использовать  в  приложении  функцию
	InitCommonControlsEx необходимо подключить заголовочный 
	файл commctrl.h, в котором она описана. 
	
	Помимо этого следует указать компоновщику расположение 
	библиотечного файла comctl32.lib, содержащего ссылку на 
	DLL и перечень находящихся в ней функций.
	
			#pragma comment(lib,"comctl32")
*/

// Элемент управления «индикатор процесса»(Progress Control).
/*
	Элемент управления Progress Control обычно используется в 
	приложениях для отображения  процесса выполнения некоторой 
	длительной операции

	Описание
	https://msdn.microsoft.com/en-us/library/windows/desktop/bb760816%28v=vs.85%29.aspx

	HWND hProgress1 = CreateWindowEx(0, PROGRESS_CLASS, NULL,
								WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
								LEFT, TOP, WIDTH, HEIGHT,
								hwndParent, NULL, GetModuleHandle(NULL), NULL);
								
	Стили
	https://msdn.microsoft.com/en-us/library/windows/desktop/bb760820%28v=vs.85%29.aspx

*/

// Сообщения индикатора процесса.
/*
	Для управления индикатором процесса используются сообщения
	https://msdn.microsoft.com/en-us/library/windows/desktop/ff485990%28v=vs.85%29.aspx
	
	Код сообщения	wParam		lParam		Описание
	============== ======== ============= =============================
	PBM_SETRANGE	0		MAKELPARAM
							(wMin, wMax)	Установка интервала для 
											индикатора
	PBM_SETPOS		nNewPos		0			Установка  текущей  позиции 
											индикатора
	PBM_DELTAPOS	nInc		0			Изменение текущей позиции 
											прибавлением смещения nInc
	PBM_SETSTEP		nStepInc	0			Установка шага приращения 
											для индикатора
	PBM_STEPIT		0			0			Изменение текущей позиции 
											прибавлением шага nStepInc
	PBM_SETBARCOLOR	0		(COLORREF)
							 clrBar			Установка цвета заполняемых 
											прямоугольников
	PBM_SETBKCOLOR	0		(COLORREF)
							clrBk			Установка цвета фона индикатора

*/

/*
	Для установки интервала индикатора следует отправить ему 
	сообщение PBM_SETRANGE, указав в параметре   lParam границы 
	интервала. 
	
	Для того чтобы упаковать дополнительную информацию в параметры 
	wParam и lParam удобно использовать следующие макросы:

		WPARAM MAKEWPARAM( WORD wLow, WORD wHigh );
		
		LPARAM MAKELPARAM( WORD wLow, WORD wHigh );
*/


// Практическая часть.
/*
	Реализовать игру «пятнашки» с индикатором процесса, который 
	будет отображать процесс собирания «пятнашек», т.е. 
	отображать, какое количество кнопок в процентном 
	отношении находится на своих местах.
*/

// Домашнее задание.


int main()
{
    return 0;
}

